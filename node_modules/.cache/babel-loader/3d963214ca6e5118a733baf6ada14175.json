{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Path template utility.\n */\n\nvar has = require(\"lodash.has\");\n\nvar util = require(\"util\");\n\nvar extras = require(\"./parserExtras\");\n\nvar parser = require('./pathTemplateParser');\n\nvar PathTemplate =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n  function PathTemplate(data) {\n    _classCallCheck(this, PathTemplate);\n\n    this.parseResult = extras.finishParse(parser.parse(data));\n  }\n\n  _createClass(PathTemplate, [{\n    key: \"match\",\n\n    /**\n     * Matches a fully-qualified path template string.\n     *\n     * @param {String} path a fully-qualified path template string\n     * @return {Object} contains const names matched to binding values\n     * @throws {TypeError} if path can't be matched to this template\n     */\n    value: function match(path) {\n      var pathSegments = path.split('/');\n      var bindings = {};\n      var segmentCount = this.size;\n      var current;\n      var index = 0;\n      this.segments.forEach(function (segment) {\n        if (index > pathSegments.length) {\n          return;\n        }\n\n        if (segment.kind === extras.BINDING) {\n          current = segment.literal;\n        } else if (segment.kind === extras.TERMINAL) {\n          if (segment.literal === '*') {\n            bindings[current] = pathSegments[index];\n            index += 1;\n          } else if (segment.literal === '**') {\n            var size = pathSegments.length - segmentCount + 1;\n            segmentCount += size - 1;\n            bindings[current] = pathSegments.slice(index, index + size).join('/');\n            index += size;\n          } else if (segment.literal === pathSegments[index]) {\n            index += 1;\n          } else {\n            var msg = util.format(\"mismatched literal (index=%d): '%s' != '%s'\", index, segment.literal, pathSegments[index]);\n            throw new TypeError(msg);\n          }\n        }\n      });\n\n      if (index !== pathSegments.length || index !== segmentCount) {\n        var msg = util.format('match error: could not instantiate a path template from %s', path);\n        throw new TypeError(msg);\n      }\n\n      return bindings;\n    }\n    /**\n     * Renders a path template using the provided bindings.\n     *\n     * @param {Object} bindings a mapping of const names to binding strings\n     * @return {String} a rendered representation of the path template\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n     *   parsed\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(bindings) {\n      var out = [];\n      var inABinding = false;\n      this.segments.forEach(function (segment) {\n        if (segment.kind === extras.BINDING) {\n          if (!has(bindings, segment.literal)) {\n            var msg = util.format('Value for key %s is not provided in %s', segment.literal, bindings);\n            throw new TypeError(msg);\n          }\n\n          var tmp = new PathTemplate(bindings[segment.literal]);\n          Array.prototype.push.apply(out, tmp.segments);\n          inABinding = true;\n        } else if (segment.kind === extras.END_BINDING) {\n          inABinding = false;\n        } else if (inABinding) {\n          return;\n        } else {\n          out.push(segment);\n        }\n      });\n      var result = formatSegments(out);\n      this.match(result);\n      return result;\n    }\n    /**\n     * Renders the path template.\n     *\n     * @return {string} contains const names matched to binding values\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return formatSegments(this.segments);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.parseResult.size;\n    }\n  }, {\n    key: \"segments\",\n    get: function get() {\n      return this.parseResult.segments;\n    }\n  }]);\n\n  return PathTemplate;\n}();\n\nexports.PathTemplate = PathTemplate;\n/**\n * Creates the string representattion for the segments.\n * @param {Object[]} segments - The array of segments.\n * @return {string} - A string representing segments in the path template\n *   format.\n */\n\nfunction formatSegments(segments) {\n  var out = '';\n  var slash = true;\n  segments.forEach(function (segment) {\n    if (segment.kind === extras.TERMINAL) {\n      if (slash) {\n        out += '/';\n      }\n\n      out += segment.literal;\n      return;\n    }\n\n    slash = true;\n\n    if (segment.kind === extras.BINDING) {\n      out += '/{' + segment.literal + '=';\n      slash = false;\n    } else {\n      out += segment.literal + '}';\n    }\n  });\n  return out.substring(1);\n}","map":null,"metadata":{},"sourceType":"script"}