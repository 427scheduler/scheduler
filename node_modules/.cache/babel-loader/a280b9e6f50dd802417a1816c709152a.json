{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar resolver_1 = require(\"./resolver\");\n\nvar dns = require(\"dns\");\n\nvar util = require(\"util\");\n\nvar service_config_1 = require(\"./service-config\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar logging = require(\"./logging\");\n\nvar constants_2 = require(\"./constants\");\n\nvar uri_parser_1 = require(\"./uri-parser\");\n\nvar net_1 = require(\"net\");\n\nvar TRACER_NAME = 'dns_resolver';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\n\n\nvar DEFAULT_PORT = 443;\nvar resolveTxtPromise = util.promisify(dns.resolveTxt);\nvar dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\n\nfunction mergeArrays() {\n  var result = [];\n\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  for (var i = 0; i < Math.max.apply(null, arrays.map(function (array) {\n    return array.length;\n  })); i++) {\n    for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {\n      var array = _arrays[_i];\n\n      if (i < array.length) {\n        result.push(array[i]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\n\n\nvar DnsResolver =\n/*#__PURE__*/\nfunction () {\n  function DnsResolver(target, listener) {\n    _classCallCheck(this, DnsResolver);\n\n    var _a, _b;\n\n    this.target = target;\n    this.listener = listener;\n    this.pendingLookupPromise = null;\n    this.pendingTxtPromise = null;\n    this.latestLookupResult = null;\n    this.latestServiceConfig = null;\n    this.latestServiceConfigError = null;\n    trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));\n    var hostPort = uri_parser_1.splitHostPort(target.path);\n\n    if (hostPort === null) {\n      this.ipResult = null;\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n        this.ipResult = [{\n          host: hostPort.host,\n          port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n        }];\n        this.dnsHostname = null;\n        this.port = null;\n      } else {\n        this.ipResult = null;\n        this.dnsHostname = hostPort.host;\n        this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n      }\n    }\n\n    this.percentage = Math.random() * 100;\n    this.defaultResolutionError = {\n      code: constants_1.Status.UNAVAILABLE,\n      details: \"Name resolution failed for target \".concat(uri_parser_1.uriToString(this.target)),\n      metadata: new metadata_1.Metadata()\n    };\n  }\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT lookups\n   */\n\n\n  _createClass(DnsResolver, [{\n    key: \"startResolution\",\n    value: function startResolution() {\n      var _this = this;\n\n      if (this.ipResult !== null) {\n        trace('Returning IP address for target ' + uri_parser_1.uriToString(this.target));\n        setImmediate(function () {\n          _this.listener.onSuccessfulResolution(_this.ipResult, null, null, {});\n        });\n        return;\n      }\n\n      if (this.dnsHostname === null) {\n        setImmediate(function () {\n          _this.listener.onError({\n            code: constants_1.Status.UNAVAILABLE,\n            details: \"Failed to parse DNS address \".concat(uri_parser_1.uriToString(_this.target)),\n            metadata: new metadata_1.Metadata()\n          });\n        });\n      } else {\n        /* We clear out latestLookupResult here to ensure that it contains the\n         * latest result since the last time we started resolving. That way, the\n         * TXT resolution handler can use it, but only if it finishes second. We\n         * don't clear out any previous service config results because it's\n         * better to use a service config that's slightly out of date than to\n         * revert to an effectively blank one. */\n        this.latestLookupResult = null;\n        var hostname = this.dnsHostname;\n        /* We lookup both address families here and then split them up later\n         * because when looking up a single family, dns.lookup outputs an error\n         * if the name exists but there are no records for that family, and that\n         * error is indistinguishable from other kinds of errors */\n\n        this.pendingLookupPromise = dnsLookupPromise(hostname, {\n          all: true\n        });\n        this.pendingLookupPromise.then(function (addressList) {\n          _this.pendingLookupPromise = null;\n          var ip4Addresses = addressList.filter(function (addr) {\n            return addr.family === 4;\n          });\n          var ip6Addresses = addressList.filter(function (addr) {\n            return addr.family === 6;\n          });\n          _this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map(function (addr) {\n            return {\n              host: addr.address,\n              port: +_this.port\n            };\n          });\n          var allAddressesString = '[' + _this.latestLookupResult.map(function (addr) {\n            return addr.host + ':' + addr.port;\n          }).join(',') + ']';\n          trace('Resolved addresses for target ' + uri_parser_1.uriToString(_this.target) + ': ' + allAddressesString);\n\n          if (_this.latestLookupResult.length === 0) {\n            _this.listener.onError(_this.defaultResolutionError);\n\n            return;\n          }\n          /* If the TXT lookup has not yet finished, both of the last two\n           * arguments will be null, which is the equivalent of getting an\n           * empty TXT response. When the TXT lookup does finish, its handler\n           * can update the service config by using the same address list */\n\n\n          _this.listener.onSuccessfulResolution(_this.latestLookupResult, _this.latestServiceConfig, _this.latestServiceConfigError, {});\n        }, function (err) {\n          trace('Resolution error for target ' + uri_parser_1.uriToString(_this.target) + ': ' + err.message);\n          _this.pendingLookupPromise = null;\n\n          _this.listener.onError(_this.defaultResolutionError);\n        });\n        /* If there already is a still-pending TXT resolution, we can just use\n         * that result when it comes in */\n\n        if (this.pendingTxtPromise === null) {\n          /* We handle the TXT query promise differently than the others because\n           * the name resolution attempt as a whole is a success even if the TXT\n           * lookup fails */\n          this.pendingTxtPromise = resolveTxtPromise(hostname);\n          this.pendingTxtPromise.then(function (txtRecord) {\n            _this.pendingTxtPromise = null;\n\n            try {\n              _this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, _this.percentage);\n            } catch (err) {\n              _this.latestServiceConfigError = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Parsing service config failed',\n                metadata: new metadata_1.Metadata()\n              };\n            }\n\n            if (_this.latestLookupResult !== null) {\n              /* We rely here on the assumption that calling this function with\n               * identical parameters will be essentialy idempotent, and calling\n               * it with the same address list and a different service config\n               * should result in a fast and seamless switchover. */\n              _this.listener.onSuccessfulResolution(_this.latestLookupResult, _this.latestServiceConfig, _this.latestServiceConfigError, {});\n            }\n          }, function (err) {\n            _this.latestServiceConfigError = {\n              code: constants_1.Status.UNAVAILABLE,\n              details: 'TXT query failed',\n              metadata: new metadata_1.Metadata()\n            };\n\n            if (_this.latestLookupResult !== null) {\n              _this.listener.onSuccessfulResolution(_this.latestLookupResult, _this.latestServiceConfig, _this.latestServiceConfigError, {});\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"updateResolution\",\n    value: function updateResolution() {\n      trace('Resolution update requested for target ' + uri_parser_1.uriToString(this.target));\n\n      if (this.pendingLookupPromise === null) {\n        this.startResolution();\n      }\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n\n  }], [{\n    key: \"getDefaultAuthority\",\n    value: function getDefaultAuthority(target) {\n      var hostPort = uri_parser_1.splitHostPort(target.path);\n\n      if (hostPort !== null) {\n        return hostPort.host;\n      } else {\n        throw new Error(\"Failed to parse target \".concat(uri_parser_1.uriToString(target)));\n      }\n    }\n  }]);\n\n  return DnsResolver;\n}();\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\n\n\nfunction setup() {\n  resolver_1.registerResolver('dns', DnsResolver);\n  resolver_1.registerDefaultScheme('dns');\n}\n\nexports.setup = setup;","map":null,"metadata":{},"sourceType":"script"}