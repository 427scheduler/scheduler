{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar channel_options_1 = require(\"./channel-options\");\n\nvar subchannel_1 = require(\"./subchannel\");\n\nvar uri_parser_1 = require(\"./uri-parser\"); // 10 seconds in milliseconds. This value is arbitrary.\n\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\n\n\nvar REF_CHECK_INTERVAL = 10000;\n\nvar SubchannelPool =\n/*#__PURE__*/\nfunction () {\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   * @param global If true, this is the global subchannel pool. Otherwise, it\n   * is the pool for a single channel.\n   */\n  function SubchannelPool(global) {\n    _classCallCheck(this, SubchannelPool);\n\n    this.global = global;\n    this.pool = Object.create(null);\n    /**\n     * A timer of a task performing a periodic subchannel cleanup.\n     */\n\n    this.cleanupTimer = null;\n  }\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n\n\n  _createClass(SubchannelPool, [{\n    key: \"unrefUnusedSubchannels\",\n    value: function unrefUnusedSubchannels() {\n      var allSubchannelsUnrefed = true;\n      /* These objects are created with Object.create(null), so they do not\n       * have a prototype, which means that for (... in ...) loops over them\n       * do not need to be filtered */\n      // eslint-disable-disable-next-line:forin\n\n      for (var channelTarget in this.pool) {\n        var subchannelObjArray = this.pool[channelTarget];\n        var refedSubchannels = subchannelObjArray.filter(function (value) {\n          return !value.subchannel.unrefIfOneRef();\n        });\n\n        if (refedSubchannels.length > 0) {\n          allSubchannelsUnrefed = false;\n        }\n        /* For each subchannel in the pool, try to unref it if it has\n         * exactly one ref (which is the ref from the pool itself). If that\n         * does happen, remove the subchannel from the pool */\n\n\n        this.pool[channelTarget] = refedSubchannels;\n      }\n      /* Currently we do not delete keys with empty values. If that results\n       * in significant memory usage we should change it. */\n      // Cancel the cleanup task if all subchannels have been unrefed.\n\n\n      if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n        clearInterval(this.cleanupTimer);\n        this.cleanupTimer = null;\n      }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */\n\n  }, {\n    key: \"ensureCleanupTask\",\n    value: function ensureCleanupTask() {\n      var _this = this;\n\n      var _a, _b;\n\n      if (this.global && this.cleanupTimer === null) {\n        this.cleanupTimer = setInterval(function () {\n          _this.unrefUnusedSubchannels();\n        }, REF_CHECK_INTERVAL); // Unref because this timer should not keep the event loop running.\n        // Call unref only if it exists to address electron/electron#21162\n\n        (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n      }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */\n\n  }, {\n    key: \"getOrCreateSubchannel\",\n    value: function getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n      this.ensureCleanupTask();\n      var channelTarget = uri_parser_1.uriToString(channelTargetUri);\n\n      if (channelTarget in this.pool) {\n        var subchannelObjArray = this.pool[channelTarget];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = subchannelObjArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var subchannelObj = _step.value;\n\n            if (subchannel_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n              return subchannelObj.subchannel;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } // If we get here, no matching subchannel was found\n\n\n      var subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);\n\n      if (!(channelTarget in this.pool)) {\n        this.pool[channelTarget] = [];\n      }\n\n      this.pool[channelTarget].push({\n        subchannelAddress: subchannelTarget,\n        channelArguments: channelArguments,\n        channelCredentials: channelCredentials,\n        subchannel: subchannel\n      });\n\n      if (this.global) {\n        subchannel.ref();\n      }\n\n      return subchannel;\n    }\n  }]);\n\n  return SubchannelPool;\n}();\n\nexports.SubchannelPool = SubchannelPool;\nvar globalSubchannelPool = new SubchannelPool(true);\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\n\nfunction getSubchannelPool(global) {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool(false);\n  }\n}\n\nexports.getSubchannelPool = getSubchannelPool;","map":null,"metadata":{},"sourceType":"script"}