{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar stream_1 = require(\"stream\");\n\nvar constants_1 = require(\"./constants\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\n\n\nfunction callErrorFromStatus(status) {\n  var message = \"\".concat(status.code, \" \").concat(constants_1.Status[status.code], \": \").concat(status.details);\n  return Object.assign(new Error(message), status);\n}\n\nexports.callErrorFromStatus = callErrorFromStatus;\n\nvar ClientUnaryCallImpl =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(ClientUnaryCallImpl, _events_1$EventEmitte);\n\n  function ClientUnaryCallImpl() {\n    _classCallCheck(this, ClientUnaryCallImpl);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ClientUnaryCallImpl).call(this));\n  }\n\n  _createClass(ClientUnaryCallImpl, [{\n    key: \"cancel\",\n    value: function cancel() {\n      var _a;\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      var _a, _b;\n\n      return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n    }\n  }]);\n\n  return ClientUnaryCallImpl;\n}(events_1.EventEmitter);\n\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\n\nvar ClientReadableStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Readable) {\n  _inherits(ClientReadableStreamImpl, _stream_1$Readable);\n\n  function ClientReadableStreamImpl(deserialize) {\n    var _this;\n\n    _classCallCheck(this, ClientReadableStreamImpl);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClientReadableStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this.deserialize = deserialize;\n    return _this;\n  }\n\n  _createClass(ClientReadableStreamImpl, [{\n    key: \"cancel\",\n    value: function cancel() {\n      var _a;\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      var _a, _b;\n\n      return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(_size) {\n      var _a;\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n  }]);\n\n  return ClientReadableStreamImpl;\n}(stream_1.Readable);\n\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\n\nvar ClientWritableStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Writable) {\n  _inherits(ClientWritableStreamImpl, _stream_1$Writable);\n\n  function ClientWritableStreamImpl(serialize) {\n    var _this2;\n\n    _classCallCheck(this, ClientWritableStreamImpl);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ClientWritableStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this2.serialize = serialize;\n    return _this2;\n  }\n\n  _createClass(ClientWritableStreamImpl, [{\n    key: \"cancel\",\n    value: function cancel() {\n      var _a;\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      var _a, _b;\n\n      return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, cb) {\n      var _a;\n\n      var context = {\n        callback: cb\n      };\n      var flags = Number(encoding);\n\n      if (!Number.isNaN(flags)) {\n        context.flags = flags;\n      }\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(cb) {\n      var _a;\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n      cb();\n    }\n  }]);\n\n  return ClientWritableStreamImpl;\n}(stream_1.Writable);\n\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\n\nvar ClientDuplexStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Duplex) {\n  _inherits(ClientDuplexStreamImpl, _stream_1$Duplex);\n\n  function ClientDuplexStreamImpl(serialize, deserialize) {\n    var _this3;\n\n    _classCallCheck(this, ClientDuplexStreamImpl);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ClientDuplexStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this3.serialize = serialize;\n    _this3.deserialize = deserialize;\n    return _this3;\n  }\n\n  _createClass(ClientDuplexStreamImpl, [{\n    key: \"cancel\",\n    value: function cancel() {\n      var _a;\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      var _a, _b;\n\n      return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(_size) {\n      var _a;\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, cb) {\n      var _a;\n\n      var context = {\n        callback: cb\n      };\n      var flags = Number(encoding);\n\n      if (!Number.isNaN(flags)) {\n        context.flags = flags;\n      }\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(cb) {\n      var _a;\n\n      (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n      cb();\n    }\n  }]);\n\n  return ClientDuplexStreamImpl;\n}(stream_1.Duplex);\n\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;","map":null,"metadata":{},"sourceType":"script"}