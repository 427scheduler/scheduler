{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar assert = require(\"assert\");\n\nvar backoff_1 = require(\"./backoff\");\n\nvar rate_limiter_1 = require(\"./rate-limiter\");\n\nvar util_1 = require(\"./util\");\n\nvar write_batch_1 = require(\"./write-batch\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\n\n\nvar MAX_BATCH_SIZE = 500;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nvar STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nvar RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nvar RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\n\nvar BatchState;\n\n(function (BatchState) {\n  BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n  BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n  BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\n\n\nvar BulkCommitBatch =\n/*#__PURE__*/\nfunction () {\n  function BulkCommitBatch(writeBatch, maxBatchSize) {\n    _classCallCheck(this, BulkCommitBatch);\n\n    this.writeBatch = writeBatch;\n    this.maxBatchSize = maxBatchSize;\n    /**\n     * The state of the batch.\n     */\n\n    this.state = BatchState.OPEN; // The set of document reference paths present in the WriteBatch.\n\n    this.docPaths = new Set(); // A deferred promise that is resolved after the batch has been sent, and a\n    // response is received.\n\n    this.completedDeferred = new util_1.Deferred(); // A map from each WriteBatch operation to its corresponding result.\n\n    this.resultsMap = new Map();\n  }\n  /**\n   * The number of writes in this batch.\n   */\n\n\n  _createClass(BulkCommitBatch, [{\n    key: \"create\",\n\n    /**\n     * Adds a `create` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    value: function create(documentRef, data) {\n      this.writeBatch.create(documentRef, data);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `delete` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the delete.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this.writeBatch.delete(documentRef, precondition);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `set` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this.writeBatch.set(documentRef, data, options);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds an `update` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      var _this$writeBatch;\n\n      for (var _len = arguments.length, preconditionOrValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        preconditionOrValues[_key - 2] = arguments[_key];\n      }\n\n      (_this$writeBatch = this.writeBatch).update.apply(_this$writeBatch, [documentRef, dataOrField].concat(preconditionOrValues));\n\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Helper to update data structures associated with the operation and\n     * return the result.\n     */\n\n  }, {\n    key: \"processOperation\",\n    value: function processOperation(documentRef) {\n      assert(!this.docPaths.has(documentRef.path), 'Batch should not contain writes to the same document');\n      assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n      this.docPaths.add(documentRef.path);\n      var deferred = new util_1.Deferred();\n      this.resultsMap.set(this.opCount, deferred);\n\n      if (this.opCount === this.maxBatchSize) {\n        this.state = BatchState.READY_TO_SEND;\n      }\n\n      return deferred.promise.then(function (result) {\n        if (result.writeTime) {\n          return new write_batch_1.WriteResult(result.writeTime);\n        } else {\n          throw result.status;\n        }\n      });\n    }\n    /**\n     * Commits the batch and returns a promise that resolves with the result of\n     * all writes in this batch.\n     */\n\n  }, {\n    key: \"bulkCommit\",\n    value: function bulkCommit() {\n      assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n      this.state = BatchState.SENT; // Capture the error stack to preserve stack tracing across async calls.\n\n      var stack = Error().stack;\n      return this.writeBatch.bulkCommit().catch(function (err) {\n        throw util_1.wrapError(err, stack);\n      });\n    }\n    /**\n     * Resolves the individual operations in the batch with the results.\n     */\n\n  }, {\n    key: \"processResults\",\n    value: function processResults(results, error) {\n      if (error === undefined) {\n        for (var i = 0; i < this.opCount; i++) {\n          this.resultsMap.get(i).resolve(results[i]);\n        }\n      } else {\n        for (var _i = 0; _i < this.opCount; _i++) {\n          this.resultsMap.get(_i).reject(error);\n        }\n      }\n\n      this.completedDeferred.resolve();\n    }\n    /**\n     * Returns a promise that resolves when the batch has been sent, and a\n     * response is received.\n     */\n\n  }, {\n    key: \"awaitBulkCommit\",\n    value: function awaitBulkCommit() {\n      this.markReadyToSend();\n      return this.completedDeferred.promise;\n    }\n  }, {\n    key: \"markReadyToSend\",\n    value: function markReadyToSend() {\n      if (this.state === BatchState.OPEN) {\n        this.state = BatchState.READY_TO_SEND;\n      }\n    }\n  }, {\n    key: \"opCount\",\n    get: function get() {\n      return this.resultsMap.size;\n    }\n  }]);\n\n  return BulkCommitBatch;\n}();\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class\n * @private\n */\n\n\nvar BulkWriter =\n/*#__PURE__*/\nfunction () {\n  function BulkWriter(firestore, enableThrottling) {\n    _classCallCheck(this, BulkWriter);\n\n    this.firestore = firestore;\n    /**\n     * The maximum number of writes that can be in a single batch.\n     */\n\n    this.maxBatchSize = MAX_BATCH_SIZE;\n    /**\n     * A queue of batches to be written.\n     */\n\n    this.batchQueue = [];\n    /**\n     * Whether this BulkWriter instance is closed. Once closed, it cannot be\n     * opened again.\n     */\n\n    this.closed = false;\n\n    if (enableThrottling) {\n      this.rateLimiter = new rate_limiter_1.RateLimiter(STARTING_MAXIMUM_OPS_PER_SECOND, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS);\n    } else {\n      this.rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n  }\n  /**\n   * Create a document with the provided data. This single operation will fail\n   * if a document exists at its location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {T} data The object to serialize as the document.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. Throws an error if the write fails.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * bulkWriter\n   *  .create(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  _createClass(BulkWriter, [{\n    key: \"create\",\n    value: function create(documentRef, data) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch(documentRef);\n      var resultPromise = bulkCommitBatch.create(documentRef, data);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch(documentRef);\n      var resultPromise = bulkCommitBatch.delete(documentRef, precondition);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch(documentRef);\n      var resultPromise = bulkCommitBatch.set(documentRef, data, options);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch(documentRef);\n\n      for (var _len2 = arguments.length, preconditionOrValues = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        preconditionOrValues[_key2 - 2] = arguments[_key2];\n      }\n\n      var resultPromise = bulkCommitBatch.update.apply(bulkCommitBatch, [documentRef, dataOrField].concat(preconditionOrValues));\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n\n  }, {\n    key: \"flush\",\n    value: function () {\n      var _flush = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var trackedBatches, writePromises;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.verifyNotClosed();\n                trackedBatches = this.batchQueue;\n                writePromises = trackedBatches.map(function (batch) {\n                  return batch.awaitBulkCommit();\n                });\n                this.sendReadyBatches();\n                _context.next = 6;\n                return Promise.all(writePromises);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function flush() {\n        return _flush.apply(this, arguments);\n      }\n\n      return flush;\n    }()\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method wil throw an error.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var flushPromise = this.flush();\n      this.closed = true;\n      return flushPromise;\n    }\n  }, {\n    key: \"verifyNotClosed\",\n    value: function verifyNotClosed() {\n      if (this.closed) {\n        throw new Error('BulkWriter has already been closed.');\n      }\n    }\n    /**\n     * Return the first eligible batch that can hold a write to the provided\n     * reference, or creates one if no eligible batches are found.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getEligibleBatch\",\n    value: function getEligibleBatch(ref) {\n      if (this.batchQueue.length > 0) {\n        var lastBatch = this.batchQueue[this.batchQueue.length - 1];\n\n        if (lastBatch.state === BatchState.OPEN && !lastBatch.docPaths.has(ref.path)) {\n          return lastBatch;\n        }\n      }\n\n      return this.createNewBatch();\n    }\n    /**\n     * Creates a new batch and adds it to the BatchQueue. If there is already a\n     * batch enqueued, sends the batch after a new one is created.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"createNewBatch\",\n    value: function createNewBatch() {\n      var newBatch = new BulkCommitBatch(this.firestore.batch(), this.maxBatchSize);\n\n      if (this.batchQueue.length > 0) {\n        this.batchQueue[this.batchQueue.length - 1].markReadyToSend();\n        this.sendReadyBatches();\n      }\n\n      this.batchQueue.push(newBatch);\n      return newBatch;\n    }\n    /**\n     * Attempts to send batches starting from the front of the BatchQueue until a\n     * batch cannot be sent.\n     *\n     * After a batch is complete, try sending batches again.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"sendReadyBatches\",\n    value: function sendReadyBatches() {\n      var _this = this;\n\n      var unsentBatches = this.batchQueue.filter(function (batch) {\n        return batch.state === BatchState.READY_TO_SEND;\n      });\n      var index = 0;\n\n      while (index < unsentBatches.length && this.isBatchSendable(unsentBatches[index])) {\n        var batch = unsentBatches[index]; // Send the batch if it is under the rate limit, or schedule another\n        // attempt after the appropriate timeout.\n\n        var delayMs = this.rateLimiter.getNextRequestDelayMs(batch.opCount);\n        assert(delayMs !== -1, 'Batch size should be under capacity');\n\n        if (delayMs === 0) {\n          this.sendBatch(batch);\n        } else {\n          backoff_1.delayExecution(function () {\n            return _this.sendReadyBatches();\n          }, delayMs);\n          break;\n        }\n\n        index++;\n      }\n    }\n    /**\n     * Sends the provided batch and processes the results. After the batch is\n     * committed, sends the next group of ready batches.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"sendBatch\",\n    value: function sendBatch(batch) {\n      var _this2 = this;\n\n      var success = this.rateLimiter.tryMakeRequest(batch.opCount);\n      assert(success, 'Batch should be under rate limit to be sent.');\n      batch.bulkCommit().then(function (results) {\n        batch.processResults(results);\n      }).catch(function (error) {\n        batch.processResults([], error);\n      }).then(function () {\n        // Remove the batch from the BatchQueue after it has been processed.\n        var batchIndex = _this2.batchQueue.indexOf(batch);\n\n        assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n\n        _this2.batchQueue.splice(batchIndex, 1);\n\n        _this2.sendReadyBatches();\n      });\n    }\n    /**\n     * Checks that the provided batch is sendable. To be sendable, a batch must:\n     * (1) be marked as READY_TO_SEND\n     * (2) not write to references that are currently in flight\n     *\n     * @private\n     */\n\n  }, {\n    key: \"isBatchSendable\",\n    value: function isBatchSendable(batch) {\n      var _this3 = this;\n\n      if (batch.state !== BatchState.READY_TO_SEND) {\n        return false;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var path = _step.value;\n          var isRefInFlight = _this3.batchQueue.filter(function (batch) {\n            return batch.state === BatchState.SENT;\n          }).find(function (batch) {\n            return batch.docPaths.has(path);\n          }) !== undefined;\n\n          if (isRefInFlight) {\n            console.warn('[BulkWriter]', \"Duplicate write to document \\\"\".concat(path, \"\\\" detected.\"), 'Writing to the same document multiple times will slow down BulkWriter. ' + 'Write to unique documents in order to maximize throughput.');\n            return {\n              v: false\n            };\n          }\n        };\n\n        for (var _iterator = batch.docPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ret = _loop();\n\n          if (typeof _ret === \"object\") return _ret.v;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Sets the maximum number of allowed operations in a batch.\n     *\n     * @private\n     */\n    // Visible for testing.\n\n  }, {\n    key: \"_setMaxBatchSize\",\n    value: function _setMaxBatchSize(size) {\n      this.maxBatchSize = size;\n    }\n  }]);\n\n  return BulkWriter;\n}();\n\nexports.BulkWriter = BulkWriter;","map":null,"metadata":{},"sourceType":"script"}