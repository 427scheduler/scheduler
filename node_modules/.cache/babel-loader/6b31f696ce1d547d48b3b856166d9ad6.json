{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _regeneratorRuntime = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar http2 = require(\"http2\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar server_call_1 = require(\"./server-call\");\n\nvar resolver_1 = require(\"./resolver\");\n\nvar logging = require(\"./logging\");\n\nvar subchannel_1 = require(\"./subchannel\");\n\nvar uri_parser_1 = require(\"./uri-parser\");\n\nvar TRACER_NAME = 'server';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nfunction noop() {}\n\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: \"The server does not implement the method \".concat(methodName),\n    metadata: new metadata_1.Metadata()\n  };\n}\n\nfunction getDefaultHandler(handlerType, methodName) {\n  var unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n\n  switch (handlerType) {\n    case 'unary':\n      return function (call, callback) {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'clientStream':\n      return function (call, callback) {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'serverStream':\n      return function (call) {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    case 'bidi':\n      return function (call) {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    default:\n      throw new Error(\"Invalid handlerType \".concat(handlerType));\n  }\n}\n\nvar Server =\n/*#__PURE__*/\nfunction () {\n  function Server(options) {\n    _classCallCheck(this, Server);\n\n    this.http2ServerList = [];\n    this.handlers = new Map();\n    this.sessions = new Set();\n    this.started = false;\n    this.options = options !== null && options !== void 0 ? options : {};\n  }\n\n  _createClass(Server, [{\n    key: \"addProtoService\",\n    value: function addProtoService() {\n      throw new Error('Not implemented. Use addService() instead');\n    }\n  }, {\n    key: \"addService\",\n    value: function addService(service, implementation) {\n      var _this = this;\n\n      if (this.started === true) {\n        throw new Error(\"Can't add a service to a started server.\");\n      }\n\n      if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n        throw new Error('addService() requires two objects as arguments');\n      }\n\n      var serviceKeys = Object.keys(service);\n\n      if (serviceKeys.length === 0) {\n        throw new Error('Cannot add an empty service to a server');\n      }\n\n      serviceKeys.forEach(function (name) {\n        var attrs = service[name];\n        var methodType;\n\n        if (attrs.requestStream) {\n          if (attrs.responseStream) {\n            methodType = 'bidi';\n          } else {\n            methodType = 'clientStream';\n          }\n        } else {\n          if (attrs.responseStream) {\n            methodType = 'serverStream';\n          } else {\n            methodType = 'unary';\n          }\n        }\n\n        var implFn = implementation[name];\n        var impl;\n\n        if (implFn === undefined && typeof attrs.originalName === 'string') {\n          implFn = implementation[attrs.originalName];\n        }\n\n        if (implFn !== undefined) {\n          impl = implFn.bind(implementation);\n        } else {\n          impl = getDefaultHandler(methodType, name);\n        }\n\n        var success = _this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n\n        if (success === false) {\n          throw new Error(\"Method handler for \".concat(attrs.path, \" already provided.\"));\n        }\n      });\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(port, creds) {\n      throw new Error('Not implemented. Use bindAsync() instead');\n    }\n  }, {\n    key: \"bindAsync\",\n    value: function bindAsync(port, creds, callback) {\n      var _this2 = this;\n\n      if (this.started === true) {\n        throw new Error('server is already started');\n      }\n\n      if (typeof port !== 'string') {\n        throw new TypeError('port must be a string');\n      }\n\n      if (creds === null || typeof creds !== 'object') {\n        throw new TypeError('creds must be an object');\n      }\n\n      if (typeof callback !== 'function') {\n        throw new TypeError('callback must be a function');\n      }\n\n      var initialPortUri = uri_parser_1.parseUri(port);\n\n      if (initialPortUri === null) {\n        throw new Error(\"Could not parse port \\\"\".concat(port, \"\\\"\"));\n      }\n\n      var portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n\n      if (portUri === null) {\n        throw new Error(\"Could not get a default scheme for port \\\"\".concat(port, \"\\\"\"));\n      }\n\n      var serverOptions = {};\n\n      if ('grpc.max_concurrent_streams' in this.options) {\n        serverOptions.settings = {\n          maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n        };\n      }\n\n      var setupServer = function setupServer() {\n        var http2Server;\n\n        if (creds._isSecure()) {\n          var secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n          http2Server = http2.createSecureServer(secureServerOptions);\n        } else {\n          http2Server = http2.createServer(serverOptions);\n        }\n\n        http2Server.setTimeout(0, noop);\n\n        _this2._setupHandlers(http2Server);\n\n        return http2Server;\n      };\n\n      var bindSpecificPort = function bindSpecificPort(addressList, portNum, previousCount) {\n        if (addressList.length === 0) {\n          return Promise.resolve({\n            port: portNum,\n            count: previousCount\n          });\n        }\n\n        return Promise.all(addressList.map(function (address) {\n          trace('Attempting to bind ' + subchannel_1.subchannelAddressToString(address));\n          var addr;\n\n          if (subchannel_1.isTcpSubchannelAddress(address)) {\n            addr = {\n              host: address.host,\n              port: portNum\n            };\n          } else {\n            addr = address;\n          }\n\n          var http2Server = setupServer();\n          return new Promise(function (resolve, reject) {\n            function onError(err) {\n              resolve(err);\n            }\n\n            http2Server.once('error', onError);\n            http2Server.listen(addr, function () {\n              trace('Successfully bound ' + subchannel_1.subchannelAddressToString(address));\n\n              _this2.http2ServerList.push(http2Server);\n\n              var boundAddress = http2Server.address();\n\n              if (typeof boundAddress === 'string') {\n                resolve(portNum);\n              } else {\n                resolve(boundAddress.port);\n              }\n\n              http2Server.removeListener('error', onError);\n            });\n          });\n        })).then(function (results) {\n          var count = 0;\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = results[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var result = _step.value;\n\n              if (typeof result === 'number') {\n                count += 1;\n\n                if (result !== portNum) {\n                  throw new Error('Invalid state: multiple port numbers added from single address');\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          return {\n            port: portNum,\n            count: count + previousCount\n          };\n        });\n      };\n\n      var bindWildcardPort = function bindWildcardPort(addressList) {\n        if (addressList.length === 0) {\n          return Promise.resolve({\n            port: 0,\n            count: 0\n          });\n        }\n\n        var address = addressList[0];\n        var http2Server = setupServer();\n        return new Promise(function (resolve, reject) {\n          function onError(err) {\n            resolve(bindWildcardPort(addressList.slice(1)));\n          }\n\n          http2Server.once('error', onError);\n          http2Server.listen(address, function () {\n            _this2.http2ServerList.push(http2Server);\n\n            resolve(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));\n            http2Server.removeListener('error', onError);\n          });\n        });\n      };\n\n      var resolverListener = {\n        onSuccessfulResolution: function onSuccessfulResolution(addressList, serviceConfig, serviceConfigError) {\n          // We only want one resolution result. Discard all future results\n          resolverListener.onSuccessfulResolution = function () {};\n\n          if (addressList.length === 0) {\n            callback(new Error(\"No addresses resolved for port \".concat(port)), 0);\n            return;\n          }\n\n          var bindResultPromise;\n\n          if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {\n            if (addressList[0].port === 0) {\n              bindResultPromise = bindWildcardPort(addressList);\n            } else {\n              bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n            }\n          } else {\n            // Use an arbitrary non-zero port for non-TCP addresses\n            bindResultPromise = bindSpecificPort(addressList, 1, 0);\n          }\n\n          bindResultPromise.then(function (bindResult) {\n            if (bindResult.count === 0) {\n              var errorString = \"No address added out of total \".concat(addressList.length, \" resolved\");\n              logging.log(constants_1.LogVerbosity.ERROR, errorString);\n              callback(new Error(errorString), 0);\n            } else {\n              if (bindResult.count < addressList.length) {\n                logging.log(constants_1.LogVerbosity.INFO, \"WARNING Only \".concat(bindResult.count, \" addresses added out of total \").concat(addressList.length, \" resolved\"));\n              }\n\n              callback(null, bindResult.port);\n            }\n          }, function (error) {\n            var errorString = \"No address added out of total \".concat(addressList.length, \" resolved\");\n            logging.log(constants_1.LogVerbosity.ERROR, errorString);\n            callback(new Error(errorString), 0);\n          });\n        },\n        onError: function onError(error) {\n          callback(new Error(error.details), 0);\n        }\n      };\n      var resolver = resolver_1.createResolver(portUri, resolverListener);\n      resolver.updateResolution();\n    }\n  }, {\n    key: \"forceShutdown\",\n    value: function forceShutdown() {\n      // Close the server if it is still running.\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.http2ServerList[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var http2Server = _step2.value;\n\n          if (http2Server.listening) {\n            http2Server.close();\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.started = false; // Always destroy any available sessions. It's possible that one or more\n      // tryShutdown() calls are in progress. Don't wait on them to finish.\n\n      this.sessions.forEach(function (session) {\n        // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n        // recognize destroy(code) as a valid signature.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        session.destroy(http2.constants.NGHTTP2_CANCEL);\n      });\n      this.sessions.clear();\n    }\n  }, {\n    key: \"register\",\n    value: function register(name, handler, serialize, deserialize, type) {\n      if (this.handlers.has(name)) {\n        return false;\n      }\n\n      this.handlers.set(name, {\n        func: handler,\n        serialize: serialize,\n        deserialize: deserialize,\n        type: type,\n        path: name\n      });\n      return true;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.http2ServerList.length === 0 || this.http2ServerList.every(function (http2Server) {\n        return http2Server.listening !== true;\n      })) {\n        throw new Error('server must be bound in order to start');\n      }\n\n      if (this.started === true) {\n        throw new Error('server is already started');\n      }\n\n      this.started = true;\n    }\n  }, {\n    key: \"tryShutdown\",\n    value: function tryShutdown(callback) {\n      var pendingChecks = 0;\n\n      function maybeCallback() {\n        pendingChecks--;\n\n        if (pendingChecks === 0) {\n          callback();\n        }\n      } // Close the server if necessary.\n\n\n      this.started = false;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.http2ServerList[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var http2Server = _step3.value;\n\n          if (http2Server.listening) {\n            pendingChecks++;\n            http2Server.close(maybeCallback);\n          }\n        } // If any sessions are active, close them gracefully.\n\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      pendingChecks += this.sessions.size;\n      this.sessions.forEach(function (session) {\n        session.close(maybeCallback);\n      });\n\n      if (pendingChecks === 0) {\n        callback();\n      }\n    }\n  }, {\n    key: \"addHttp2Port\",\n    value: function addHttp2Port() {\n      throw new Error('Not yet implemented');\n    }\n  }, {\n    key: \"_setupHandlers\",\n    value: function _setupHandlers(http2Server) {\n      var _this3 = this;\n\n      if (http2Server === null) {\n        return;\n      }\n\n      http2Server.on('stream', function (stream, headers) {\n        var _a;\n\n        var contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n        if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n          stream.respond(_defineProperty({}, http2.constants.HTTP2_HEADER_STATUS, http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE), {\n            endStream: true\n          });\n          return;\n        }\n\n        try {\n          var path = headers[http2.constants.HTTP2_HEADER_PATH];\n          trace('Received call to method ' + path + ' at address ' + ((_a = http2Server.address()) === null || _a === void 0 ? void 0 : _a.toString()));\n\n          var handler = _this3.handlers.get(path);\n\n          if (handler === undefined) {\n            trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n            throw getUnimplementedStatusResponse(path);\n          }\n\n          var call = new server_call_1.Http2ServerCallStream(stream, handler, _this3.options);\n          var metadata = call.receiveMetadata(headers);\n\n          switch (handler.type) {\n            case 'unary':\n              handleUnary(call, handler, metadata);\n              break;\n\n            case 'clientStream':\n              handleClientStreaming(call, handler, metadata);\n              break;\n\n            case 'serverStream':\n              handleServerStreaming(call, handler, metadata);\n              break;\n\n            case 'bidi':\n              handleBidiStreaming(call, handler, metadata);\n              break;\n\n            default:\n              throw new Error(\"Unknown handler type: \".concat(handler.type));\n          }\n        } catch (err) {\n          var _call = new server_call_1.Http2ServerCallStream(stream, null, _this3.options);\n\n          if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n          }\n\n          _call.sendError(err);\n        }\n      });\n      http2Server.on('session', function (session) {\n        if (!_this3.started) {\n          session.destroy();\n          return;\n        }\n\n        _this3.sessions.add(session);\n      });\n    }\n  }]);\n\n  return Server;\n}();\n\nexports.Server = Server;\n\nfunction handleUnary(_x, _x2, _x3) {\n  return _handleUnary.apply(this, arguments);\n}\n\nfunction _handleUnary() {\n  _handleUnary = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(call, handler, metadata) {\n    var emitter, request;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            emitter = new server_call_1.ServerUnaryCallImpl(call, metadata);\n            _context.next = 3;\n            return call.receiveUnaryMessage();\n\n          case 3:\n            request = _context.sent;\n\n            if (!(request === undefined || call.cancelled)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 6:\n            emitter.request = request;\n            handler.func(emitter, function (err, value, trailer, flags) {\n              call.sendUnaryMessage(err, value, trailer, flags);\n            });\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _handleUnary.apply(this, arguments);\n}\n\nfunction handleClientStreaming(call, handler, metadata) {\n  var stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nfunction handleServerStreaming(_x4, _x5, _x6) {\n  return _handleServerStreaming.apply(this, arguments);\n}\n\nfunction _handleServerStreaming() {\n  _handleServerStreaming = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(call, handler, metadata) {\n    var request, stream;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return call.receiveUnaryMessage();\n\n          case 2:\n            request = _context2.sent;\n\n            if (!(request === undefined || call.cancelled)) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 5:\n            stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize);\n            stream.request = request;\n            handler.func(stream);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _handleServerStreaming.apply(this, arguments);\n}\n\nfunction handleBidiStreaming(call, handler, metadata) {\n  var stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n}","map":null,"metadata":{},"sourceType":"script"}