{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _regeneratorRuntime = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _get = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/get\");\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _assertThisInitialized = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _defineProperty = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _defaultResponseHeade;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar http2 = require(\"http2\");\n\nvar stream_1 = require(\"stream\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar stream_decoder_1 = require(\"./stream-decoder\");\n\nvar logging = require(\"./logging\");\n\nvar TRACER_NAME = 'server_call';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nvar GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nvar GRPC_ENCODING_HEADER = 'grpc-encoding';\nvar GRPC_MESSAGE_HEADER = 'grpc-message';\nvar GRPC_STATUS_HEADER = 'grpc-status';\nvar GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nvar DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nvar deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nvar defaultResponseHeaders = (_defaultResponseHeade = {}, _defineProperty(_defaultResponseHeade, GRPC_ACCEPT_ENCODING_HEADER, 'identity'), _defineProperty(_defaultResponseHeade, GRPC_ENCODING_HEADER, 'identity'), _defineProperty(_defaultResponseHeade, http2.constants.HTTP2_HEADER_STATUS, http2.constants.HTTP_STATUS_OK), _defineProperty(_defaultResponseHeade, http2.constants.HTTP2_HEADER_CONTENT_TYPE, 'application/grpc+proto'), _defaultResponseHeade);\nvar defaultResponseOptions = {\n  waitForTrailers: true\n};\n\nvar ServerUnaryCallImpl =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(ServerUnaryCallImpl, _events_1$EventEmitte);\n\n  function ServerUnaryCallImpl(call, metadata) {\n    var _this;\n\n    _classCallCheck(this, ServerUnaryCallImpl);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ServerUnaryCallImpl).call(this));\n    _this.call = call;\n    _this.metadata = metadata;\n    _this.cancelled = false;\n    _this.request = null;\n\n    _this.call.setupSurfaceCall(_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  _createClass(ServerUnaryCallImpl, [{\n    key: \"getPeer\",\n    value: function getPeer() {\n      throw new Error('not implemented yet');\n    }\n  }, {\n    key: \"sendMetadata\",\n    value: function sendMetadata(responseMetadata) {\n      this.call.sendMetadata(responseMetadata);\n    }\n  }]);\n\n  return ServerUnaryCallImpl;\n}(events_1.EventEmitter);\n\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\n\nvar ServerReadableStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Readable) {\n  _inherits(ServerReadableStreamImpl, _stream_1$Readable);\n\n  function ServerReadableStreamImpl(call, metadata, deserialize) {\n    var _this2;\n\n    _classCallCheck(this, ServerReadableStreamImpl);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ServerReadableStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this2.call = call;\n    _this2.metadata = metadata;\n    _this2.deserialize = deserialize;\n    _this2.cancelled = false;\n\n    _this2.call.setupSurfaceCall(_assertThisInitialized(_this2));\n\n    _this2.call.setupReadable(_assertThisInitialized(_this2));\n\n    return _this2;\n  }\n\n  _createClass(ServerReadableStreamImpl, [{\n    key: \"_read\",\n    value: function _read(size) {\n      if (!this.call.consumeUnpushedMessages(this)) {\n        return;\n      }\n\n      this.call.resume();\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      throw new Error('not implemented yet');\n    }\n  }, {\n    key: \"sendMetadata\",\n    value: function sendMetadata(responseMetadata) {\n      this.call.sendMetadata(responseMetadata);\n    }\n  }]);\n\n  return ServerReadableStreamImpl;\n}(stream_1.Readable);\n\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\n\nvar ServerWritableStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Writable) {\n  _inherits(ServerWritableStreamImpl, _stream_1$Writable);\n\n  function ServerWritableStreamImpl(call, metadata, serialize) {\n    var _this3;\n\n    _classCallCheck(this, ServerWritableStreamImpl);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ServerWritableStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this3.call = call;\n    _this3.metadata = metadata;\n    _this3.serialize = serialize;\n    _this3.cancelled = false;\n    _this3.request = null;\n    _this3.trailingMetadata = new metadata_1.Metadata();\n\n    _this3.call.setupSurfaceCall(_assertThisInitialized(_this3));\n\n    _this3.on('error', function (err) {\n      _this3.call.sendError(err);\n\n      _this3.end();\n    });\n\n    return _this3;\n  }\n\n  _createClass(ServerWritableStreamImpl, [{\n    key: \"getPeer\",\n    value: function getPeer() {\n      throw new Error('not implemented yet');\n    }\n  }, {\n    key: \"sendMetadata\",\n    value: function sendMetadata(responseMetadata) {\n      this.call.sendMetadata(responseMetadata);\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n      try {\n        var response = this.call.serializeMessage(chunk);\n\n        if (!this.call.write(response)) {\n          this.call.once('drain', callback);\n          return;\n        }\n      } catch (err) {\n        err.code = constants_1.Status.INTERNAL;\n        this.emit('error', err);\n      }\n\n      callback();\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(callback) {\n      this.call.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata: this.trailingMetadata\n      });\n      callback(null);\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"end\",\n    value: function end(metadata) {\n      if (metadata) {\n        this.trailingMetadata = metadata;\n      }\n\n      _get(_getPrototypeOf(ServerWritableStreamImpl.prototype), \"end\", this).call(this);\n    }\n  }]);\n\n  return ServerWritableStreamImpl;\n}(stream_1.Writable);\n\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\n\nvar ServerDuplexStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Duplex) {\n  _inherits(ServerDuplexStreamImpl, _stream_1$Duplex);\n\n  function ServerDuplexStreamImpl(call, metadata, serialize, deserialize) {\n    var _this4;\n\n    _classCallCheck(this, ServerDuplexStreamImpl);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ServerDuplexStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this4.call = call;\n    _this4.metadata = metadata;\n    _this4.serialize = serialize;\n    _this4.deserialize = deserialize;\n    _this4.cancelled = false;\n    _this4.trailingMetadata = new metadata_1.Metadata();\n\n    _this4.call.setupSurfaceCall(_assertThisInitialized(_this4));\n\n    _this4.call.setupReadable(_assertThisInitialized(_this4));\n\n    _this4.on('error', function (err) {\n      _this4.call.sendError(err);\n\n      _this4.end();\n    });\n\n    return _this4;\n  }\n\n  _createClass(ServerDuplexStreamImpl, [{\n    key: \"getPeer\",\n    value: function getPeer() {\n      throw new Error('not implemented yet');\n    }\n  }, {\n    key: \"sendMetadata\",\n    value: function sendMetadata(responseMetadata) {\n      this.call.sendMetadata(responseMetadata);\n    }\n  }]);\n\n  return ServerDuplexStreamImpl;\n}(stream_1.Duplex);\n\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\nServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end;\nvar noopTimer = setTimeout(function () {}, 0); // Internal class that wraps the HTTP2 request.\n\nvar Http2ServerCallStream =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte2) {\n  _inherits(Http2ServerCallStream, _events_1$EventEmitte2);\n\n  function Http2ServerCallStream(stream, handler, options) {\n    var _this5;\n\n    _classCallCheck(this, Http2ServerCallStream);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Http2ServerCallStream).call(this));\n    _this5.stream = stream;\n    _this5.handler = handler;\n    _this5.options = options;\n    _this5.cancelled = false;\n    _this5.deadline = noopTimer;\n    _this5.wantTrailers = false;\n    _this5.metadataSent = false;\n    _this5.canPush = false;\n    _this5.isPushPending = false;\n    _this5.bufferedMessages = [];\n    _this5.messagesToPush = [];\n    _this5.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    _this5.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n    _this5.stream.once('error', function (err) {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n\n    _this5.stream.once('close', function () {\n      _this5.cancelled = true;\n\n      _this5.emit('cancelled', 'cancelled');\n    });\n\n    _this5.stream.on('drain', function () {\n      _this5.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      _this5.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n\n    if ('grpc.max_receive_message_length' in options) {\n      _this5.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n\n    return _this5;\n  }\n\n  _createClass(Http2ServerCallStream, [{\n    key: \"checkCancelled\",\n    value: function checkCancelled() {\n      /* In some cases the stream can become destroyed before the close event\n       * fires. That creates a race condition that this check works around */\n      if (this.stream.destroyed) {\n        this.cancelled = true;\n      }\n\n      return this.cancelled;\n    }\n  }, {\n    key: \"sendMetadata\",\n    value: function sendMetadata(customMetadata) {\n      if (this.checkCancelled()) {\n        return;\n      }\n\n      if (this.metadataSent) {\n        return;\n      }\n\n      this.metadataSent = true;\n      var custom = customMetadata ? customMetadata.toHttp2Headers() : null; // TODO(cjihrig): Include compression headers.\n\n      var headers = Object.assign(defaultResponseHeaders, custom);\n      this.stream.respond(headers, defaultResponseOptions);\n    }\n  }, {\n    key: \"receiveMetadata\",\n    value: function receiveMetadata(headers) {\n      var metadata = metadata_1.Metadata.fromHttp2Headers(headers); // TODO(cjihrig): Receive compression metadata.\n\n      var timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n      if (timeoutHeader.length > 0) {\n        var match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n        if (match === null) {\n          var err = new Error('Invalid deadline');\n          err.code = constants_1.Status.OUT_OF_RANGE;\n          this.sendError(err);\n          return;\n        }\n\n        var timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n        this.deadline = setTimeout(handleExpiredDeadline, timeout, this);\n        metadata.remove(GRPC_TIMEOUT_HEADER);\n      } // Remove several headers that should not be propagated to the application\n\n\n      metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n      metadata.remove(http2.constants.HTTP2_HEADER_TE);\n      metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n      metadata.remove('grpc-encoding');\n      metadata.remove('grpc-accept-encoding');\n      return metadata;\n    }\n  }, {\n    key: \"receiveUnaryMessage\",\n    value: function receiveUnaryMessage() {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        var stream = _this6.stream;\n        var chunks = [];\n        var totalLength = 0;\n        stream.on('data', function (data) {\n          chunks.push(data);\n          totalLength += data.byteLength;\n        });\n        stream.once('end',\n        /*#__PURE__*/\n        _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee() {\n          var requestBytes;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  try {\n                    requestBytes = Buffer.concat(chunks, totalLength);\n\n                    if (_this6.maxReceiveMessageSize !== -1 && requestBytes.length > _this6.maxReceiveMessageSize) {\n                      _this6.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: \"Received message larger than max (\".concat(requestBytes.length, \" vs. \").concat(_this6.maxReceiveMessageSize, \")\")\n                      });\n\n                      resolve();\n                    }\n\n                    resolve(_this6.deserializeMessage(requestBytes));\n                  } catch (err) {\n                    err.code = constants_1.Status.INTERNAL;\n\n                    _this6.sendError(err);\n\n                    resolve();\n                  }\n\n                case 1:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        })));\n      });\n    }\n  }, {\n    key: \"serializeMessage\",\n    value: function serializeMessage(value) {\n      var messageBuffer = this.handler.serialize(value); // TODO(cjihrig): Call compression aware serializeMessage().\n\n      var byteLength = messageBuffer.byteLength;\n      var output = Buffer.allocUnsafe(byteLength + 5);\n      output.writeUInt8(0, 0);\n      output.writeUInt32BE(byteLength, 1);\n      messageBuffer.copy(output, 5);\n      return output;\n    }\n  }, {\n    key: \"deserializeMessage\",\n    value: function deserializeMessage(bytes) {\n      // TODO(cjihrig): Call compression aware deserializeMessage().\n      var receivedMessage = bytes.slice(5);\n      return this.handler.deserialize(receivedMessage);\n    }\n  }, {\n    key: \"sendUnaryMessage\",\n    value: function () {\n      var _sendUnaryMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(err, value, metadata, flags) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.checkCancelled()) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                if (!metadata) {\n                  metadata = new metadata_1.Metadata();\n                }\n\n                if (!err) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                if (!Object.prototype.hasOwnProperty.call(err, 'metadata')) {\n                  err.metadata = metadata;\n                }\n\n                this.sendError(err);\n                return _context2.abrupt(\"return\");\n\n              case 7:\n                try {\n                  response = this.serializeMessage(value);\n                  this.write(response);\n                  this.sendStatus({\n                    code: constants_1.Status.OK,\n                    details: 'OK',\n                    metadata: metadata\n                  });\n                } catch (err) {\n                  err.code = constants_1.Status.INTERNAL;\n                  this.sendError(err);\n                }\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sendUnaryMessage(_x, _x2, _x3, _x4) {\n        return _sendUnaryMessage.apply(this, arguments);\n      }\n\n      return sendUnaryMessage;\n    }()\n  }, {\n    key: \"sendStatus\",\n    value: function sendStatus(statusObj) {\n      var _this7 = this;\n\n      var _a;\n\n      if (this.checkCancelled()) {\n        return;\n      }\n\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n      clearTimeout(this.deadline);\n\n      if (!this.wantTrailers) {\n        this.wantTrailers = true;\n        this.stream.once('wantTrailers', function () {\n          var _Object$assign;\n\n          var trailersToSend = Object.assign((_Object$assign = {}, _defineProperty(_Object$assign, GRPC_STATUS_HEADER, statusObj.code), _defineProperty(_Object$assign, GRPC_MESSAGE_HEADER, encodeURI(statusObj.details)), _Object$assign), statusObj.metadata.toHttp2Headers());\n\n          _this7.stream.sendTrailers(trailersToSend);\n        });\n        this.sendMetadata();\n        this.stream.end();\n      }\n    }\n  }, {\n    key: \"sendError\",\n    value: function sendError(error) {\n      if (this.checkCancelled()) {\n        return;\n      }\n\n      var status = {\n        code: constants_1.Status.UNKNOWN,\n        details: 'message' in error ? error.message : 'Unknown Error',\n        metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : new metadata_1.Metadata()\n      };\n\n      if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n        status.code = error.code;\n\n        if ('details' in error && typeof error.details === 'string') {\n          status.details = error.details;\n        }\n      }\n\n      this.sendStatus(status);\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk) {\n      if (this.checkCancelled()) {\n        return;\n      }\n\n      if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n        this.sendError({\n          code: constants_1.Status.RESOURCE_EXHAUSTED,\n          details: \"Sent message larger than max (\".concat(chunk.length, \" vs. \").concat(this.maxSendMessageSize, \")\")\n        });\n        return;\n      }\n\n      this.sendMetadata();\n      return this.stream.write(chunk);\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.stream.resume();\n    }\n  }, {\n    key: \"setupSurfaceCall\",\n    value: function setupSurfaceCall(call) {\n      this.once('cancelled', function (reason) {\n        call.cancelled = true;\n        call.emit('cancelled', reason);\n      });\n    }\n  }, {\n    key: \"setupReadable\",\n    value: function setupReadable(readable) {\n      var _this8 = this;\n\n      var decoder = new stream_decoder_1.StreamDecoder();\n      this.stream.on('data',\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee3(data) {\n          var messages, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, message;\n\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  messages = decoder.write(data);\n                  _iteratorNormalCompletion = true;\n                  _didIteratorError = false;\n                  _iteratorError = undefined;\n                  _context3.prev = 4;\n                  _iterator = messages[Symbol.iterator]();\n\n                case 6:\n                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                    _context3.next = 15;\n                    break;\n                  }\n\n                  message = _step.value;\n\n                  if (!(_this8.maxReceiveMessageSize !== -1 && message.length > _this8.maxReceiveMessageSize)) {\n                    _context3.next = 11;\n                    break;\n                  }\n\n                  _this8.sendError({\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: \"Received message larger than max (\".concat(message.length, \" vs. \").concat(_this8.maxReceiveMessageSize, \")\")\n                  });\n\n                  return _context3.abrupt(\"return\");\n\n                case 11:\n                  _this8.pushOrBufferMessage(readable, message);\n\n                case 12:\n                  _iteratorNormalCompletion = true;\n                  _context3.next = 6;\n                  break;\n\n                case 15:\n                  _context3.next = 21;\n                  break;\n\n                case 17:\n                  _context3.prev = 17;\n                  _context3.t0 = _context3[\"catch\"](4);\n                  _didIteratorError = true;\n                  _iteratorError = _context3.t0;\n\n                case 21:\n                  _context3.prev = 21;\n                  _context3.prev = 22;\n\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n\n                case 24:\n                  _context3.prev = 24;\n\n                  if (!_didIteratorError) {\n                    _context3.next = 27;\n                    break;\n                  }\n\n                  throw _iteratorError;\n\n                case 27:\n                  return _context3.finish(24);\n\n                case 28:\n                  return _context3.finish(21);\n\n                case 29:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, null, [[4, 17, 21, 29], [22,, 24, 28]]);\n        }));\n\n        return function (_x5) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      this.stream.once('end', function () {\n        _this8.pushOrBufferMessage(readable, null);\n      });\n    }\n  }, {\n    key: \"consumeUnpushedMessages\",\n    value: function consumeUnpushedMessages(readable) {\n      this.canPush = true;\n\n      while (this.messagesToPush.length > 0) {\n        var nextMessage = this.messagesToPush.shift();\n        var canPush = readable.push(nextMessage);\n\n        if (nextMessage === null || canPush === false) {\n          this.canPush = false;\n          break;\n        }\n      }\n\n      return this.canPush;\n    }\n  }, {\n    key: \"pushOrBufferMessage\",\n    value: function pushOrBufferMessage(readable, messageBytes) {\n      if (this.isPushPending) {\n        this.bufferedMessages.push(messageBytes);\n      } else {\n        this.pushMessage(readable, messageBytes);\n      }\n    }\n  }, {\n    key: \"pushMessage\",\n    value: function () {\n      var _pushMessage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(readable, messageBytes) {\n        var deserialized;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(messageBytes === null)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                if (this.canPush) {\n                  readable.push(null);\n                } else {\n                  this.messagesToPush.push(null);\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 3:\n                this.isPushPending = true;\n                _context4.prev = 4;\n                _context4.next = 7;\n                return this.deserializeMessage(messageBytes);\n\n              case 7:\n                deserialized = _context4.sent;\n\n                if (this.canPush) {\n                  if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                  }\n                } else {\n                  this.messagesToPush.push(deserialized);\n                }\n\n                _context4.next = 16;\n                break;\n\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](4);\n                // Ignore any remaining messages when errors occur.\n                this.bufferedMessages.length = 0;\n                _context4.t0.code = constants_1.Status.INTERNAL;\n                readable.emit('error', _context4.t0);\n\n              case 16:\n                this.isPushPending = false;\n\n                if (this.bufferedMessages.length > 0) {\n                  this.pushMessage(readable, this.bufferedMessages.shift());\n                }\n\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[4, 11]]);\n      }));\n\n      function pushMessage(_x6, _x7) {\n        return _pushMessage.apply(this, arguments);\n      }\n\n      return pushMessage;\n    }()\n  }]);\n\n  return Http2ServerCallStream;\n}(events_1.EventEmitter);\n\nexports.Http2ServerCallStream = Http2ServerCallStream;\n\nfunction handleExpiredDeadline(call) {\n  var err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}","map":null,"metadata":{},"sourceType":"script"}