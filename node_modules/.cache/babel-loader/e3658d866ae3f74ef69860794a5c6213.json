{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _get = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/get\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _assertThisInitialized = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar metadata_1 = require(\"./metadata\");\n\nvar call_stream_1 = require(\"./call-stream\");\n\nvar constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\n\n\nvar InterceptorConfigurationError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(InterceptorConfigurationError, _Error);\n\n  function InterceptorConfigurationError(message) {\n    var _this;\n\n    _classCallCheck(this, InterceptorConfigurationError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InterceptorConfigurationError).call(this, message));\n    _this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(_assertThisInitialized(_this), InterceptorConfigurationError);\n    return _this;\n  }\n\n  return InterceptorConfigurationError;\n}(_wrapNativeSuper(Error));\n\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\n\nvar ListenerBuilder =\n/*#__PURE__*/\nfunction () {\n  function ListenerBuilder() {\n    _classCallCheck(this, ListenerBuilder);\n\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n\n  _createClass(ListenerBuilder, [{\n    key: \"withOnReceiveMetadata\",\n    value: function withOnReceiveMetadata(onReceiveMetadata) {\n      this.metadata = onReceiveMetadata;\n      return this;\n    }\n  }, {\n    key: \"withOnReceiveMessage\",\n    value: function withOnReceiveMessage(onReceiveMessage) {\n      this.message = onReceiveMessage;\n      return this;\n    }\n  }, {\n    key: \"withOnReceiveStatus\",\n    value: function withOnReceiveStatus(onReceiveStatus) {\n      this.status = onReceiveStatus;\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      return {\n        onReceiveMetadata: this.metadata,\n        onReceiveMessage: this.message,\n        onReceiveStatus: this.status\n      };\n    }\n  }]);\n\n  return ListenerBuilder;\n}();\n\nexports.ListenerBuilder = ListenerBuilder;\n\nvar RequesterBuilder =\n/*#__PURE__*/\nfunction () {\n  function RequesterBuilder() {\n    _classCallCheck(this, RequesterBuilder);\n\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n\n  _createClass(RequesterBuilder, [{\n    key: \"withStart\",\n    value: function withStart(start) {\n      this.start = start;\n      return this;\n    }\n  }, {\n    key: \"withSendMessage\",\n    value: function withSendMessage(sendMessage) {\n      this.message = sendMessage;\n      return this;\n    }\n  }, {\n    key: \"withHalfClose\",\n    value: function withHalfClose(halfClose) {\n      this.halfClose = halfClose;\n      return this;\n    }\n  }, {\n    key: \"withCancel\",\n    value: function withCancel(cancel) {\n      this.cancel = cancel;\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      return {\n        start: this.start,\n        sendMessage: this.message,\n        halfClose: this.halfClose,\n        cancel: this.cancel\n      };\n    }\n  }]);\n\n  return RequesterBuilder;\n}();\n\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\n\nvar defaultListener = {\n  onReceiveMetadata: function onReceiveMetadata(metadata, next) {\n    next(metadata);\n  },\n  onReceiveMessage: function onReceiveMessage(message, next) {\n    next(message);\n  },\n  onReceiveStatus: function onReceiveStatus(status, next) {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\n\nvar defaultRequester = {\n  start: function start(metadata, listener, next) {\n    next(metadata, listener);\n  },\n  sendMessage: function sendMessage(message, next) {\n    next(message);\n  },\n  halfClose: function halfClose(next) {\n    next();\n  },\n  cancel: function cancel(next) {\n    next();\n  }\n};\n\nvar InterceptingCall =\n/*#__PURE__*/\nfunction () {\n  function InterceptingCall(nextCall, requester) {\n    _classCallCheck(this, InterceptingCall);\n\n    var _a, _b, _c, _d;\n\n    this.nextCall = nextCall;\n    /**\n     * Indicates that a message has been passed to the listener's onReceiveMessage\n     * method it has not been passed to the corresponding next callback\n     */\n\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n\n    this.pendingHalfClose = false;\n\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  _createClass(InterceptingCall, [{\n    key: \"cancelWithStatus\",\n    value: function cancelWithStatus(status, details) {\n      var _this2 = this;\n\n      this.requester.cancel(function () {\n        _this2.nextCall.cancelWithStatus(status, details);\n      });\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      return this.nextCall.getPeer();\n    }\n  }, {\n    key: \"start\",\n    value: function start(metadata, interceptingListener) {\n      var _this3 = this;\n\n      var _a, _b, _c, _d, _e, _f;\n\n      var fullInterceptingListener = {\n        onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : function (metadata) {},\n        onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : function (message) {},\n        onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : function (status) {}\n      };\n      this.requester.start(metadata, fullInterceptingListener, function (md, listener) {\n        var _a, _b, _c;\n\n        var finalInterceptingListener;\n\n        if (call_stream_1.isInterceptingListener(listener)) {\n          finalInterceptingListener = listener;\n        } else {\n          var fullListener = {\n            onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n            onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n            onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n          };\n          finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n        }\n\n        _this3.nextCall.start(md, finalInterceptingListener);\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"sendMessageWithContext\",\n    value: function sendMessageWithContext(context, message) {\n      var _this4 = this;\n\n      this.processingMessage = true;\n      this.requester.sendMessage(message, function (finalMessage) {\n        _this4.processingMessage = false;\n\n        _this4.nextCall.sendMessageWithContext(context, finalMessage);\n\n        if (_this4.pendingHalfClose) {\n          _this4.nextCall.halfClose();\n        }\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(message) {\n      this.sendMessageWithContext({}, message);\n    }\n  }, {\n    key: \"startRead\",\n    value: function startRead() {\n      this.nextCall.startRead();\n    }\n  }, {\n    key: \"halfClose\",\n    value: function halfClose() {\n      var _this5 = this;\n\n      this.requester.halfClose(function () {\n        if (_this5.processingMessage) {\n          _this5.pendingHalfClose = true;\n        } else {\n          _this5.nextCall.halfClose();\n        }\n      });\n    }\n  }, {\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      this.nextCall.setCredentials(credentials);\n    }\n  }]);\n\n  return InterceptingCall;\n}();\n\nexports.InterceptingCall = InterceptingCall;\n\nfunction getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent = null;\n  var propagateFlags;\n  var credentials;\n\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    propagateFlags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n\n  var call = channel.createCall(path, deadline, host, parent, propagateFlags);\n\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\n\n\nvar BaseInterceptingCall =\n/*#__PURE__*/\nfunction () {\n  function BaseInterceptingCall(call, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition) {\n    _classCallCheck(this, BaseInterceptingCall);\n\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n\n  _createClass(BaseInterceptingCall, [{\n    key: \"cancelWithStatus\",\n    value: function cancelWithStatus(status, details) {\n      this.call.cancelWithStatus(status, details);\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      return this.call.getPeer();\n    }\n  }, {\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      this.call.setCredentials(credentials);\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"sendMessageWithContext\",\n    value: function sendMessageWithContext(context, message) {\n      var serialized;\n\n      try {\n        serialized = this.methodDefinition.requestSerialize(message);\n        this.call.sendMessageWithContext(context, serialized);\n      } catch (e) {\n        this.call.cancelWithStatus(constants_1.Status.INTERNAL, \"Request message serialization failure: \".concat(e.message));\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(message) {\n      this.sendMessageWithContext({}, message);\n    }\n  }, {\n    key: \"start\",\n    value: function start(metadata, interceptingListener) {\n      var _this6 = this;\n\n      var readError = null;\n      this.call.start(metadata, {\n        onReceiveMetadata: function onReceiveMetadata(metadata) {\n          var _a;\n\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n        },\n        onReceiveMessage: function onReceiveMessage(message) {\n          var _a; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n          var deserialized;\n\n          try {\n            deserialized = _this6.methodDefinition.responseDeserialize(message);\n            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n          } catch (e) {\n            readError = {\n              code: constants_1.Status.INTERNAL,\n              details: \"Response message parsing error: \".concat(e.message),\n              metadata: new metadata_1.Metadata()\n            };\n\n            _this6.call.cancelWithStatus(readError.code, readError.details);\n          }\n        },\n        onReceiveStatus: function onReceiveStatus(status) {\n          var _a, _b;\n\n          if (readError) {\n            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n          } else {\n            (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"startRead\",\n    value: function startRead() {\n      this.call.startRead();\n    }\n  }, {\n    key: \"halfClose\",\n    value: function halfClose() {\n      this.call.halfClose();\n    }\n  }]);\n\n  return BaseInterceptingCall;\n}();\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\n\n\nvar BaseUnaryInterceptingCall =\n/*#__PURE__*/\nfunction (_BaseInterceptingCall) {\n  _inherits(BaseUnaryInterceptingCall, _BaseInterceptingCall);\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function BaseUnaryInterceptingCall(call, methodDefinition) {\n    _classCallCheck(this, BaseUnaryInterceptingCall);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BaseUnaryInterceptingCall).call(this, call, methodDefinition));\n  }\n\n  _createClass(BaseUnaryInterceptingCall, [{\n    key: \"start\",\n    value: function start(metadata, listener) {\n      var _a, _b;\n\n      var receivedMessage = false;\n      var wrapperListener = {\n        onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : function (metadata) {},\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onReceiveMessage: function onReceiveMessage(message) {\n          var _a;\n\n          receivedMessage = true;\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n        },\n        onReceiveStatus: function onReceiveStatus(status) {\n          var _a, _b;\n\n          if (!receivedMessage) {\n            (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n          }\n\n          (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n        }\n      };\n\n      _get(_getPrototypeOf(BaseUnaryInterceptingCall.prototype), \"start\", this).call(this, metadata, wrapperListener);\n\n      this.call.startRead();\n    }\n  }]);\n\n  return BaseUnaryInterceptingCall;\n}(BaseInterceptingCall);\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\n\n\nvar BaseStreamingInterceptingCall =\n/*#__PURE__*/\nfunction (_BaseInterceptingCall2) {\n  _inherits(BaseStreamingInterceptingCall, _BaseInterceptingCall2);\n\n  function BaseStreamingInterceptingCall() {\n    _classCallCheck(this, BaseStreamingInterceptingCall);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BaseStreamingInterceptingCall).apply(this, arguments));\n  }\n\n  return BaseStreamingInterceptingCall;\n}(BaseInterceptingCall);\n\nfunction getBottomInterceptingCall(channel, options, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n  var call = getCall(channel, methodDefinition.path, options);\n\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nfunction getInterceptingCall(interceptorArgs, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n\n  var interceptors = []; // Interceptors passed to the call override interceptors passed to the client constructor\n\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(function (provider) {\n      return provider(methodDefinition);\n    })).filter(function (interceptor) {\n      return interceptor;\n    }); // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(function (provider) {\n      return provider(methodDefinition);\n    })).filter(function (interceptor) {\n      return interceptor;\n    }); // Filter out falsy values when providers return nothing\n  }\n\n  var interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n\n  var getCall = interceptors.reduceRight(function (nextCall, nextInterceptor) {\n    return function (currentOptions) {\n      return nextInterceptor(currentOptions, nextCall);\n    };\n  }, function (finalOptions) {\n    return getBottomInterceptingCall(channel, finalOptions, methodDefinition);\n  });\n  return getCall(interceptorOptions);\n}\n\nexports.getInterceptingCall = getInterceptingCall;","map":null,"metadata":{},"sourceType":"script"}