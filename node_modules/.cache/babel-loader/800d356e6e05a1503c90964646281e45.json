{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar call_stream_1 = require(\"./call-stream\");\n\nvar channel_credentials_1 = require(\"./channel-credentials\");\n\nvar resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nvar subchannel_pool_1 = require(\"./subchannel-pool\");\n\nvar picker_1 = require(\"./picker\");\n\nvar constants_1 = require(\"./constants\");\n\nvar filter_stack_1 = require(\"./filter-stack\");\n\nvar call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nvar deadline_filter_1 = require(\"./deadline-filter\");\n\nvar compression_filter_1 = require(\"./compression-filter\");\n\nvar resolver_1 = require(\"./resolver\");\n\nvar service_config_1 = require(\"./service-config\");\n\nvar logging_1 = require(\"./logging\");\n\nvar max_message_size_filter_1 = require(\"./max-message-size-filter\");\n\nvar http_proxy_1 = require(\"./http_proxy\");\n\nvar uri_parser_1 = require(\"./uri-parser\");\n\nvar ConnectivityState;\n\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 1] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 3] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n\nvar nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  var callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nvar ChannelImplementation =\n/*#__PURE__*/\nfunction () {\n  function ChannelImplementation(target, credentials, options) {\n    var _this = this;\n\n    _classCallCheck(this, ChannelImplementation);\n\n    var _a;\n\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n\n    if (options) {\n      if (typeof options !== 'object' || !Object.values(options).every(function (value) {\n        return typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined';\n      })) {\n        throw new TypeError('Channel options must be an object with string or number values');\n      }\n    }\n\n    var originalTargetUri = uri_parser_1.parseUri(target);\n\n    if (originalTargetUri === null) {\n      throw new Error(\"Could not parse target name \\\"\".concat(target, \"\\\"\"));\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n\n\n    var defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n\n    if (defaultSchemeMapResult === null) {\n      throw new Error(\"Could not find a default scheme for target name \\\"\".concat(target, \"\\\"\"));\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n\n    var proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_a = options['grpc.use_local_subchannel_pool']) !== null && _a !== void 0 ? _a : 0) === 0);\n    var channelControlHelper = {\n      createSubchannel: function createSubchannel(subchannelAddress, subchannelArgs) {\n        return _this.subchannelPool.getOrCreateSubchannel(_this.target, subchannelAddress, Object.assign({}, _this.options, subchannelArgs), _this.credentials);\n      },\n      updateState: function updateState(connectivityState, picker) {\n        _this.currentPicker = picker;\n\n        var queueCopy = _this.pickQueue.slice();\n\n        _this.pickQueue = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = queueCopy[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _step$value = _step.value,\n                callStream = _step$value.callStream,\n                callMetadata = _step$value.callMetadata;\n\n            _this.tryPick(callStream, callMetadata);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        _this.updateState(connectivityState);\n      },\n      requestReresolution: function requestReresolution() {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      }\n    }; // TODO(murgatroid99): check channel arg for default service config\n\n    var defaultServiceConfig = {\n      loadBalancingConfig: [],\n      methodConfig: []\n    };\n\n    if (options['grpc.service_config']) {\n      defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(options['grpc.service_config']));\n    }\n\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, defaultServiceConfig);\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this)]);\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  _createClass(ChannelImplementation, [{\n    key: \"tryPick\",\n    value: function tryPick(callStream, callMetadata) {\n      var _this2 = this;\n\n      var _a, _b, _c;\n\n      var pickResult = this.currentPicker.pick({\n        metadata: callMetadata\n      });\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', 'Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n\n      switch (pickResult.pickResultType) {\n        case picker_1.PickResultType.COMPLETE:\n          if (pickResult.subchannel === null) {\n            callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n          } else {\n            /* If the subchannel is not in the READY state, that indicates a bug\n             * somewhere in the load balancer or picker. So, we log an error and\n             * queue the pick to be tried again later. */\n            if (pickResult.subchannel.getConnectivityState() !== ConnectivityState.READY) {\n              logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n              this.pickQueue.push({\n                callStream: callStream,\n                callMetadata: callMetadata\n              });\n              break;\n            }\n            /* We need to clone the callMetadata here because the transparent\n             * retry code in the promise resolution handler use the same\n             * callMetadata object, so it needs to stay unmodified */\n\n\n            callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(function (finalMetadata) {\n              var _a, _b;\n\n              var subchannelState = pickResult.subchannel.getConnectivityState();\n\n              if (subchannelState === ConnectivityState.READY) {\n                try {\n                  pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a = pickResult.extraFilterFactory) !== null && _a !== void 0 ? _a : undefined);\n                  /* If we reach this point, the call stream has started\n                   * successfully */\n\n                  (_b = pickResult.onCallStarted) === null || _b === void 0 ? void 0 : _b.call(pickResult);\n                } catch (error) {\n                  if (error.code === 'ERR_HTTP2_GOAWAY_SESSION') {\n                    /* An error here indicates that something went wrong with\n                     * the picked subchannel's http2 stream right before we\n                     * tried to start the stream. We are handling a promise\n                     * result here, so this is asynchronous with respect to the\n                     * original tryPick call, so calling it again is not\n                     * recursive. We call tryPick immediately instead of\n                     * queueing this pick again because handling the queue is\n                     * triggered by state changes, and we want to immediately\n                     * check if the state has already changed since the\n                     * previous tryPick call. We do this instead of cancelling\n                     * the stream because the correct behavior may be\n                     * re-queueing instead, based on the logic in the rest of\n                     * tryPick */\n                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchannel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Retrying pick');\n\n                    _this2.tryPick(callStream, callMetadata);\n                  } else {\n                    logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Failed to start call on picked subchanel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Ending call');\n                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to start HTTP/2 stream');\n                  }\n                }\n              } else {\n                /* The logic for doing this here is the same as in the catch\n                 * block above */\n                logging_1.trace(constants_1.LogVerbosity.INFO, 'channel', 'Picked subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick');\n\n                _this2.tryPick(callStream, callMetadata);\n              }\n            }, function (error) {\n              // We assume the error code isn't 0 (Status.OK)\n              callStream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, \"Getting metadata from plugin failed with error: \".concat(error.message));\n            });\n          }\n\n          break;\n\n        case picker_1.PickResultType.QUEUE:\n          this.pickQueue.push({\n            callStream: callStream,\n            callMetadata: callMetadata\n          });\n          break;\n\n        case picker_1.PickResultType.TRANSIENT_FAILURE:\n          if (callMetadata.getOptions().waitForReady) {\n            this.pickQueue.push({\n              callStream: callStream,\n              callMetadata: callMetadata\n            });\n          } else {\n            callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Invalid state: unknown pickResultType \".concat(pickResult.pickResultType));\n      }\n    }\n  }, {\n    key: \"removeConnectivityStateWatcher\",\n    value: function removeConnectivityStateWatcher(watcherObject) {\n      var watcherIndex = this.connectivityStateWatchers.findIndex(function (value) {\n        return value === watcherObject;\n      });\n\n      if (watcherIndex >= 0) {\n        this.connectivityStateWatchers.splice(watcherIndex, 1);\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(newState) {\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', uri_parser_1.uriToString(this.target) + ' ' + ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n      this.connectivityState = newState;\n      var watchersCopy = this.connectivityStateWatchers.slice();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = watchersCopy[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var watcherObject = _step2.value;\n\n          if (newState !== watcherObject.currentState) {\n            clearTimeout(watcherObject.timer);\n            this.removeConnectivityStateWatcher(watcherObject);\n            watcherObject.callback();\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_startCallStream\",\n    value: function _startCallStream(stream, metadata) {\n      this.tryPick(stream, metadata.clone());\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.resolvingLoadBalancer.destroy();\n      this.updateState(ConnectivityState.SHUTDOWN);\n      this.subchannelPool.unrefUnusedSubchannels();\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget() {\n      return uri_parser_1.uriToString(this.target);\n    }\n  }, {\n    key: \"getConnectivityState\",\n    value: function getConnectivityState(tryToConnect) {\n      var connectivityState = this.connectivityState;\n\n      if (tryToConnect) {\n        this.resolvingLoadBalancer.exitIdle();\n      }\n\n      return connectivityState;\n    }\n  }, {\n    key: \"watchConnectivityState\",\n    value: function watchConnectivityState(currentState, deadline, callback) {\n      var _this3 = this;\n\n      var deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      var now = new Date();\n\n      if (deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n\n      var watcherObject = {\n        currentState: currentState,\n        callback: callback,\n        timer: setTimeout(function () {\n          _this3.removeConnectivityStateWatcher(watcherObject);\n\n          callback(new Error('Deadline passed without connectivity state change'));\n        }, deadlineDate.getTime() - now.getTime())\n      };\n      this.connectivityStateWatchers.push(watcherObject);\n    }\n  }, {\n    key: \"createCall\",\n    value: function createCall(method, deadline, host, parentCall, // eslint-disable-line @typescript-eslint/no-explicit-any\n    propagateFlags) {\n      if (typeof method !== 'string') {\n        throw new TypeError('Channel#createCall: method must be a string');\n      }\n\n      if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n        throw new TypeError('Channel#createCall: deadline must be a number or Date');\n      }\n\n      if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n        throw new Error('Channel has been shut down');\n      }\n\n      var callNumber = getNewCallNumber();\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', uri_parser_1.uriToString(this.target) + ' createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n      var finalOptions = {\n        deadline: deadline,\n        flags: propagateFlags || 0,\n        host: host || this.defaultAuthority,\n        parentCall: parentCall || null\n      };\n      var stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n      return stream;\n    }\n  }]);\n\n  return ChannelImplementation;\n}();\n\nexports.ChannelImplementation = ChannelImplementation;","map":null,"metadata":{},"sourceType":"script"}