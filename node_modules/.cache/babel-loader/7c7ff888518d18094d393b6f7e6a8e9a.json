{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar http2 = require(\"http2\");\n\nvar constants_1 = require(\"./constants\");\n\nvar filter_stack_1 = require(\"./filter-stack\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar stream_decoder_1 = require(\"./stream-decoder\");\n\nvar logging = require(\"./logging\");\n\nvar constants_2 = require(\"./constants\");\n\nvar TRACER_NAME = 'call_stream';\nvar _http2$constants = http2.constants,\n    HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS,\n    HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n    NGHTTP2_CANCEL = _http2$constants.NGHTTP2_CANCEL;\n\nfunction isInterceptingListener(listener) {\n  return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\n\nexports.isInterceptingListener = isInterceptingListener;\n\nvar InterceptingListenerImpl =\n/*#__PURE__*/\nfunction () {\n  function InterceptingListenerImpl(listener, nextListener) {\n    _classCallCheck(this, InterceptingListenerImpl);\n\n    this.listener = listener;\n    this.nextListener = nextListener;\n    this.processingMessage = false;\n    this.pendingStatus = null;\n  }\n\n  _createClass(InterceptingListenerImpl, [{\n    key: \"onReceiveMetadata\",\n    value: function onReceiveMetadata(metadata) {\n      var _this = this;\n\n      this.listener.onReceiveMetadata(metadata, function (metadata) {\n        _this.nextListener.onReceiveMetadata(metadata);\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"onReceiveMessage\",\n    value: function onReceiveMessage(message) {\n      var _this2 = this;\n\n      /* If this listener processes messages asynchronously, the last message may\n       * be reordered with respect to the status */\n      this.processingMessage = true;\n      this.listener.onReceiveMessage(message, function (msg) {\n        _this2.processingMessage = false;\n\n        _this2.nextListener.onReceiveMessage(msg);\n\n        if (_this2.pendingStatus) {\n          _this2.nextListener.onReceiveStatus(_this2.pendingStatus);\n        }\n      });\n    }\n  }, {\n    key: \"onReceiveStatus\",\n    value: function onReceiveStatus(status) {\n      var _this3 = this;\n\n      this.listener.onReceiveStatus(status, function (processedStatus) {\n        if (_this3.processingMessage) {\n          _this3.pendingStatus = processedStatus;\n        } else {\n          _this3.nextListener.onReceiveStatus(processedStatus);\n        }\n      });\n    }\n  }]);\n\n  return InterceptingListenerImpl;\n}();\n\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\n\nvar Http2CallStream =\n/*#__PURE__*/\nfunction () {\n  function Http2CallStream(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n    var _this4 = this;\n\n    _classCallCheck(this, Http2CallStream);\n\n    this.methodName = methodName;\n    this.channel = channel;\n    this.options = options;\n    this.channelCallCredentials = channelCallCredentials;\n    this.callNumber = callNumber;\n    this.http2Stream = null;\n    this.pendingRead = false;\n    this.isWriteFilterPending = false;\n    this.pendingWrite = null;\n    this.pendingWriteCallback = null;\n    this.writesClosed = false;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    this.unfilteredReadMessages = []; // Status code mapped from :status. To be used if grpc-status is not received\n\n    this.mappedStatusCode = constants_1.Status.UNKNOWN; // This is populated (non-null) if and only if the call has ended\n\n    this.finalStatus = null;\n    this.subchannel = null;\n    this.listener = null;\n    this.filterStack = filterStackFactory.createFilter(this);\n    this.credentials = channelCallCredentials;\n\n    this.disconnectListener = function () {\n      _this4.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new metadata_1.Metadata()\n      });\n    };\n  }\n\n  _createClass(Http2CallStream, [{\n    key: \"outputStatus\",\n    value: function outputStatus() {\n      var _a;\n      /* Precondition: this.finalStatus !== null */\n\n\n      if (!this.statusOutput) {\n        this.statusOutput = true;\n        var filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n\n        if (this.subchannel) {\n          this.subchannel.callUnref();\n          this.subchannel.removeDisconnectListener(this.disconnectListener);\n        }\n      }\n    }\n  }, {\n    key: \"trace\",\n    value: function trace(text) {\n      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n\n  }, {\n    key: \"endCall\",\n    value: function endCall(status) {\n      /* If the status is OK and a new status comes in (e.g. from a\n       * deserialization failure), that new status takes priority */\n      if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n        this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n        this.finalStatus = status;\n        this.maybeOutputStatus();\n      }\n\n      this.destroyHttp2Stream();\n    }\n  }, {\n    key: \"maybeOutputStatus\",\n    value: function maybeOutputStatus() {\n      if (this.finalStatus !== null) {\n        /* The combination check of readsClosed and that the two message buffer\n         * arrays are empty checks that there all incoming data has been fully\n         * processed */\n        if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {\n          this.outputStatus();\n        }\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(message) {\n      var _this5 = this;\n\n      this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n      this.canPush = false;\n      process.nextTick(function () {\n        var _a;\n\n        (_a = _this5.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n\n        _this5.maybeOutputStatus();\n      });\n    }\n  }, {\n    key: \"handleFilterError\",\n    value: function handleFilterError(error) {\n      this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n  }, {\n    key: \"handleFilteredRead\",\n    value: function handleFilteredRead(message) {\n      /* If we the call has already ended with an error, we don't want to do\n       * anything with this message. Dropping it on the floor is correct\n       * behavior */\n      if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n        this.maybeOutputStatus();\n        return;\n      }\n\n      this.isReadFilterPending = false;\n\n      if (this.canPush) {\n        this.http2Stream.pause();\n        this.push(message);\n      } else {\n        this.trace('unpushedReadMessages.push message of length ' + message.length);\n        this.unpushedReadMessages.push(message);\n      }\n\n      if (this.unfilteredReadMessages.length > 0) {\n        /* nextMessage is guaranteed not to be undefined because\n           unfilteredReadMessages is non-empty */\n        var nextMessage = this.unfilteredReadMessages.shift();\n        this.filterReceivedMessage(nextMessage);\n      }\n    }\n  }, {\n    key: \"filterReceivedMessage\",\n    value: function filterReceivedMessage(framedMessage) {\n      /* If we the call has already ended with an error, we don't want to do\n       * anything with this message. Dropping it on the floor is correct\n       * behavior */\n      if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n        this.maybeOutputStatus();\n        return;\n      }\n\n      this.trace('filterReceivedMessage of length ' + framedMessage.length);\n      this.isReadFilterPending = true;\n      this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n  }, {\n    key: \"tryPush\",\n    value: function tryPush(messageBytes) {\n      if (this.isReadFilterPending) {\n        this.trace('unfilteredReadMessages.push message of length ' + (messageBytes && messageBytes.length));\n        this.unfilteredReadMessages.push(messageBytes);\n      } else {\n        this.filterReceivedMessage(messageBytes);\n      }\n    }\n  }, {\n    key: \"handleTrailers\",\n    value: function handleTrailers(headers) {\n      var headersString = '';\n\n      for (var _i = 0, _Object$keys = Object.keys(headers); _i < _Object$keys.length; _i++) {\n        var header = _Object$keys[_i];\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n\n      this.trace('Received server trailers:\\n' + headersString);\n      var metadata;\n\n      try {\n        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n      } catch (e) {\n        metadata = new metadata_1.Metadata();\n      }\n\n      var metadataMap = metadata.getMap();\n      var code = this.mappedStatusCode;\n\n      if (code === constants_1.Status.UNKNOWN && typeof metadataMap['grpc-status'] === 'string') {\n        var receivedStatus = Number(metadataMap['grpc-status']);\n\n        if (receivedStatus in constants_1.Status) {\n          code = receivedStatus;\n          this.trace('received status code ' + receivedStatus + ' from server');\n        }\n\n        metadata.remove('grpc-status');\n      }\n\n      var details = '';\n\n      if (typeof metadataMap['grpc-message'] === 'string') {\n        details = decodeURI(metadataMap['grpc-message']);\n        metadata.remove('grpc-message');\n        this.trace('received status details string \"' + details + '\" from server');\n      }\n\n      var status = {\n        code: code,\n        details: details,\n        metadata: metadata\n      };\n      var finalStatus;\n\n      try {\n        // Attempt to assign final status.\n        finalStatus = this.filterStack.receiveTrailers(status);\n      } catch (error) {\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall({\n          code: constants_1.Status.INTERNAL,\n          details: 'Failed to process received status',\n          metadata: new metadata_1.Metadata()\n        });\n        return;\n      } // This is a no-op if the call was already ended when handling headers.\n\n\n      this.endCall(finalStatus);\n    }\n  }, {\n    key: \"attachHttp2Stream\",\n    value: function attachHttp2Stream(stream, subchannel, extraFilterFactory) {\n      var _this6 = this;\n\n      if (extraFilterFactory !== undefined) {\n        this.filterStack = new filter_stack_1.FilterStack([this.filterStack, extraFilterFactory.createFilter(this)]);\n      }\n\n      if (this.finalStatus !== null) {\n        stream.close(NGHTTP2_CANCEL);\n      } else {\n        this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n        this.http2Stream = stream;\n        this.subchannel = subchannel;\n        subchannel.addDisconnectListener(this.disconnectListener);\n        subchannel.callRef();\n        stream.on('response', function (headers, flags) {\n          var _a;\n\n          var headersString = '';\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(headers); _i2 < _Object$keys2.length; _i2++) {\n            var header = _Object$keys2[_i2];\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n          }\n\n          _this6.trace('Received server headers:\\n' + headersString);\n\n          switch (headers[':status']) {\n            // TODO(murgatroid99): handle 100 and 101\n            case 400:\n              _this6.mappedStatusCode = constants_1.Status.INTERNAL;\n              break;\n\n            case 401:\n              _this6.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n              break;\n\n            case 403:\n              _this6.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n              break;\n\n            case 404:\n              _this6.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n              break;\n\n            case 429:\n            case 502:\n            case 503:\n            case 504:\n              _this6.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n              break;\n\n            default:\n              _this6.mappedStatusCode = constants_1.Status.UNKNOWN;\n          }\n\n          if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n            _this6.handleTrailers(headers);\n          } else {\n            var metadata;\n\n            try {\n              metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n            } catch (error) {\n              _this6.endCall({\n                code: constants_1.Status.UNKNOWN,\n                details: error.message,\n                metadata: new metadata_1.Metadata()\n              });\n\n              return;\n            }\n\n            try {\n              var finalMetadata = _this6.filterStack.receiveMetadata(metadata);\n\n              (_a = _this6.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n            } catch (error) {\n              _this6.endCall({\n                code: constants_1.Status.UNKNOWN,\n                details: error.message,\n                metadata: new metadata_1.Metadata()\n              });\n            }\n          }\n        });\n        stream.on('trailers', this.handleTrailers.bind(this));\n        stream.on('data', function (data) {\n          _this6.trace('receive HTTP/2 data frame of length ' + data.length);\n\n          var messages = _this6.decoder.write(data);\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = messages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var message = _step.value;\n\n              _this6.trace('parsed message of length ' + message.length);\n\n              _this6.tryPush(message);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        });\n        stream.on('end', function () {\n          _this6.readsClosed = true;\n\n          _this6.maybeOutputStatus();\n        });\n        stream.on('close', function () {\n          var _a;\n\n          _this6.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n          /* If we have a final status with an OK status code, that means that\n           * we have received all of the messages and we have processed the\n           * trailers and the call completed successfully, so it doesn't matter\n           * how the stream ends after that */\n\n\n          if (((_a = _this6.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n            return;\n          }\n\n          var code;\n          var details = '';\n\n          switch (stream.rstCode) {\n            case http2.constants.NGHTTP2_NO_ERROR:\n              /* If we get a NO_ERROR code and we already have a status, the\n               * stream completed properly and we just haven't fully processed\n               * it yet */\n              if (_this6.finalStatus !== null) {\n                return;\n              }\n\n              code = constants_1.Status.INTERNAL;\n              details = \"Received RST_STREAM with code \".concat(stream.rstCode);\n              break;\n\n            case http2.constants.NGHTTP2_REFUSED_STREAM:\n              code = constants_1.Status.UNAVAILABLE;\n              details = 'Stream refused by server';\n              break;\n\n            case http2.constants.NGHTTP2_CANCEL:\n              code = constants_1.Status.CANCELLED;\n              details = 'Call cancelled';\n              break;\n\n            case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n              code = constants_1.Status.RESOURCE_EXHAUSTED;\n              details = 'Bandwidth exhausted';\n              break;\n\n            case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n              code = constants_1.Status.PERMISSION_DENIED;\n              details = 'Protocol not secure enough';\n              break;\n\n            default:\n              code = constants_1.Status.INTERNAL;\n              details = \"Received RST_STREAM with code \".concat(stream.rstCode);\n          } // This is a no-op if trailers were received at all.\n          // This is OK, because status codes emitted here correspond to more\n          // catastrophic issues that prevent us from receiving trailers in the\n          // first place.\n\n\n          _this6.endCall({\n            code: code,\n            details: details,\n            metadata: new metadata_1.Metadata()\n          });\n        });\n        stream.on('error', function (err) {\n          /* We need an error handler here to stop \"Uncaught Error\" exceptions\n           * from bubbling up. However, errors here should all correspond to\n           * \"close\" events, where we will handle the error more granularly */\n        });\n\n        if (!this.pendingRead) {\n          stream.pause();\n        }\n\n        if (this.pendingWrite) {\n          if (!this.pendingWriteCallback) {\n            throw new Error('Invalid state in write handling code');\n          }\n\n          this.trace('sending data chunk of length ' + this.pendingWrite.length + ' (deferred)');\n          stream.write(this.pendingWrite, this.pendingWriteCallback);\n        }\n\n        this.maybeCloseWrites();\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start(metadata, listener) {\n      this.trace('Sending metadata');\n      this.listener = listener;\n\n      this.channel._startCallStream(this, metadata);\n    }\n  }, {\n    key: \"destroyHttp2Stream\",\n    value: function destroyHttp2Stream() {\n      var _a; // The http2 stream could already have been destroyed if cancelWithStatus\n      // is called in response to an internal http2 error.\n\n\n      if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n        /* If the call has ended with an OK status, communicate that when closing\n         * the stream, partly to avoid a situation in which we detect an error\n         * RST_STREAM as a result after we have the status */\n        var code;\n\n        if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n          code = http2.constants.NGHTTP2_NO_ERROR;\n        } else {\n          code = http2.constants.NGHTTP2_CANCEL;\n        }\n\n        this.http2Stream.close(code);\n      }\n    }\n  }, {\n    key: \"cancelWithStatus\",\n    value: function cancelWithStatus(status, details) {\n      this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n      this.endCall({\n        code: status,\n        details: details,\n        metadata: new metadata_1.Metadata()\n      });\n    }\n  }, {\n    key: \"getDeadline\",\n    value: function getDeadline() {\n      return this.options.deadline;\n    }\n  }, {\n    key: \"getCredentials\",\n    value: function getCredentials() {\n      return this.credentials;\n    }\n  }, {\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      this.credentials = this.channelCallCredentials.compose(credentials);\n    }\n  }, {\n    key: \"getStatus\",\n    value: function getStatus() {\n      return this.finalStatus;\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      throw new Error('Not yet implemented');\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod() {\n      return this.methodName;\n    }\n  }, {\n    key: \"getHost\",\n    value: function getHost() {\n      return this.options.host;\n    }\n  }, {\n    key: \"startRead\",\n    value: function startRead() {\n      /* If the stream has ended with an error, we should not emit any more\n       * messages and we should communicate that the stream has ended */\n      if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n        this.readsClosed = true;\n        this.maybeOutputStatus();\n        return;\n      }\n\n      this.canPush = true;\n\n      if (this.http2Stream === null) {\n        this.pendingRead = true;\n      } else {\n        if (this.unpushedReadMessages.length > 0) {\n          var nextMessage = this.unpushedReadMessages.shift();\n          this.push(nextMessage);\n          return;\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit */\n\n\n        this.http2Stream.resume();\n      }\n    }\n  }, {\n    key: \"maybeCloseWrites\",\n    value: function maybeCloseWrites() {\n      if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {\n        this.trace('calling end() on HTTP/2 stream');\n        this.http2Stream.end();\n      }\n    }\n  }, {\n    key: \"sendMessageWithContext\",\n    value: function sendMessageWithContext(context, message) {\n      var _this7 = this;\n\n      var _a;\n\n      this.trace('write() called with message of length ' + message.length);\n      var writeObj = {\n        message: message,\n        flags: context.flags\n      };\n      var cb = (_a = context.callback) !== null && _a !== void 0 ? _a : function () {};\n      this.isWriteFilterPending = true;\n      this.filterStack.sendMessage(Promise.resolve(writeObj)).then(function (message) {\n        _this7.isWriteFilterPending = false;\n\n        if (_this7.http2Stream === null) {\n          _this7.trace('deferring writing data chunk of length ' + message.message.length);\n\n          _this7.pendingWrite = message.message;\n          _this7.pendingWriteCallback = cb;\n        } else {\n          _this7.trace('sending data chunk of length ' + message.message.length);\n\n          _this7.http2Stream.write(message.message, cb);\n\n          _this7.maybeCloseWrites();\n        }\n      }, this.handleFilterError.bind(this));\n    }\n  }, {\n    key: \"halfClose\",\n    value: function halfClose() {\n      this.trace('end() called');\n      this.writesClosed = true;\n      this.maybeCloseWrites();\n    }\n  }]);\n\n  return Http2CallStream;\n}();\n\nexports.Http2CallStream = Http2CallStream;","map":null,"metadata":{},"sourceType":"script"}