{"ast":null,"code":"/*! firebase-admin v8.12.1 */\n\"use strict\";\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar remote_config_utils_1 = require(\"./remote-config-utils\");\n\nvar utils = require(\"../utils/index\");\n\nvar validator = require(\"../utils/validator\"); // Remote Config backend constants\n\n\nvar FIREBASE_REMOTE_CONFIG_V1_API = 'https://firebaseremoteconfig.googleapis.com/v1';\nvar FIREBASE_REMOTE_CONFIG_HEADERS = {\n  'X-Firebase-Client': 'fire-admin-node/8.12.1',\n  // There is a known issue in which the ETag is not properly returned in cases where the request\n  // does not specify a compression type. Currently, it is required to include the header\n  // `Accept-Encoding: gzip` or equivalent in all requests.\n  // https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\n  'Accept-Encoding': 'gzip'\n};\nvar TagColor;\n\n(function (TagColor) {\n  TagColor[\"BLUE\"] = \"Blue\";\n  TagColor[\"BROWN\"] = \"Brown\";\n  TagColor[\"CYAN\"] = \"Cyan\";\n  TagColor[\"DEEP_ORANGE\"] = \"Red Orange\";\n  TagColor[\"GREEN\"] = \"Green\";\n  TagColor[\"INDIGO\"] = \"Indigo\";\n  TagColor[\"LIME\"] = \"Lime\";\n  TagColor[\"ORANGE\"] = \"Orange\";\n  TagColor[\"PINK\"] = \"Pink\";\n  TagColor[\"PURPLE\"] = \"Purple\";\n  TagColor[\"TEAL\"] = \"Teal\";\n})(TagColor = exports.TagColor || (exports.TagColor = {}));\n/**\n * Class that facilitates sending requests to the Firebase Remote Config backend API.\n *\n * @private\n */\n\n\nvar RemoteConfigApiClient =\n/** @class */\nfunction () {\n  function RemoteConfigApiClient(app) {\n    this.app = app;\n\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'First argument passed to admin.remoteConfig() must be a valid Firebase app instance.');\n    }\n\n    this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n  }\n\n  RemoteConfigApiClient.prototype.getTemplate = function () {\n    var _this = this;\n\n    return this.getUrl().then(function (url) {\n      var request = {\n        method: 'GET',\n        url: url + \"/remoteConfig\",\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS\n      };\n      return _this.httpClient.send(request);\n    }).then(function (resp) {\n      if (!validator.isNonEmptyString(resp.headers['etag'])) {\n        throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');\n      }\n\n      return {\n        conditions: resp.data.conditions,\n        parameters: resp.data.parameters,\n        parameterGroups: resp.data.parameterGroups,\n        etag: resp.headers['etag']\n      };\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.validateTemplate = function (template) {\n    var _this = this;\n\n    this.validateRemoteConfigTemplate(template);\n    return this.sendPutRequest(template, template.etag, true).then(function (resp) {\n      if (!validator.isNonEmptyString(resp.headers['etag'])) {\n        throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');\n      }\n\n      return {\n        conditions: resp.data.conditions,\n        parameters: resp.data.parameters,\n        parameterGroups: resp.data.parameterGroups,\n        // validating a template returns an etag with the suffix -0 means that your update \n        // was successfully validated. We set the etag back to the original etag of the template\n        // to allow future operations.\n        etag: template.etag\n      };\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.publishTemplate = function (template, options) {\n    var _this = this;\n\n    this.validateRemoteConfigTemplate(template);\n    var ifMatch = template.etag;\n\n    if (options && options.force == true) {\n      // setting `If-Match: *` forces the Remote Config template to be updated\n      // and circumvent the ETag, and the protection from that it provides.\n      ifMatch = '*';\n    }\n\n    return this.sendPutRequest(template, ifMatch).then(function (resp) {\n      if (!validator.isNonEmptyString(resp.headers['etag'])) {\n        throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');\n      }\n\n      return {\n        conditions: resp.data.conditions,\n        parameters: resp.data.parameters,\n        parameterGroups: resp.data.parameterGroups,\n        etag: resp.headers['etag']\n      };\n    }).catch(function (err) {\n      throw _this.toFirebaseError(err);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.sendPutRequest = function (template, etag, validateOnly) {\n    var _this = this;\n\n    var path = 'remoteConfig';\n\n    if (validateOnly) {\n      path += '?validate_only=true';\n    }\n\n    return this.getUrl().then(function (url) {\n      var request = {\n        method: 'PUT',\n        url: url + \"/\" + path,\n        headers: __assign(__assign({}, FIREBASE_REMOTE_CONFIG_HEADERS), {\n          'If-Match': etag\n        }),\n        data: {\n          conditions: template.conditions,\n          parameters: template.parameters,\n          parameterGroups: template.parameterGroups\n        }\n      };\n      return _this.httpClient.send(request);\n    });\n  };\n\n  RemoteConfigApiClient.prototype.getUrl = function () {\n    return this.getProjectIdPrefix().then(function (projectIdPrefix) {\n      return FIREBASE_REMOTE_CONFIG_V1_API + \"/\" + projectIdPrefix;\n    });\n  };\n\n  RemoteConfigApiClient.prototype.getProjectIdPrefix = function () {\n    var _this = this;\n\n    if (this.projectIdPrefix) {\n      return Promise.resolve(this.projectIdPrefix);\n    }\n\n    return utils.findProjectId(this.app).then(function (projectId) {\n      if (!validator.isNonEmptyString(projectId)) {\n        throw new remote_config_utils_1.FirebaseRemoteConfigError('unknown-error', 'Failed to determine project ID. Initialize the SDK with service account credentials, or ' + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT ' + 'environment variable.');\n      }\n\n      _this.projectIdPrefix = \"projects/\" + projectId;\n      return _this.projectIdPrefix;\n    });\n  };\n\n  RemoteConfigApiClient.prototype.toFirebaseError = function (err) {\n    if (err instanceof error_1.PrefixedFirebaseError) {\n      return err;\n    }\n\n    var response = err.response;\n\n    if (!response.isJson()) {\n      return new remote_config_utils_1.FirebaseRemoteConfigError('unknown-error', \"Unexpected response with status: \" + response.status + \" and body: \" + response.text);\n    }\n\n    var error = response.data.error || {};\n    var code = 'unknown-error';\n\n    if (error.status && error.status in ERROR_CODE_MAPPING) {\n      code = ERROR_CODE_MAPPING[error.status];\n    }\n\n    var message = error.message || \"Unknown server error: \" + response.text;\n    return new remote_config_utils_1.FirebaseRemoteConfigError(code, message);\n  };\n  /**\n   * Checks if the given RemoteConfigTemplate object is valid.\n   * The object must have valid parameters, parameter groups, conditions, and an etag.\n   *\n   * @param {RemoteConfigTemplate} template A RemoteConfigTemplate object to be validated.\n   */\n\n\n  RemoteConfigApiClient.prototype.validateRemoteConfigTemplate = function (template) {\n    if (!validator.isNonNullObject(template)) {\n      throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', \"Invalid Remote Config template: \" + JSON.stringify(template));\n    }\n\n    if (!validator.isNonEmptyString(template.etag)) {\n      throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'ETag must be a non-empty string.');\n    }\n\n    if (!validator.isNonNullObject(template.parameters)) {\n      throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');\n    }\n\n    if (!validator.isNonNullObject(template.parameterGroups)) {\n      throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');\n    }\n\n    if (!validator.isArray(template.conditions)) {\n      throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');\n    }\n  };\n\n  return RemoteConfigApiClient;\n}();\n\nexports.RemoteConfigApiClient = RemoteConfigApiClient;\nvar ERROR_CODE_MAPPING = {\n  ABORTED: 'aborted',\n  ALREADY_EXISTS: \"already-exists\",\n  INVALID_ARGUMENT: 'invalid-argument',\n  FAILED_PRECONDITION: 'failed-precondition',\n  NOT_FOUND: 'not-found',\n  OUT_OF_RANGE: 'out-of-range',\n  PERMISSION_DENIED: 'permission-denied',\n  RESOURCE_EXHAUSTED: 'resource-exhausted',\n  UNAUTHENTICATED: 'unauthenticated',\n  UNKNOWN: 'unknown-error'\n};","map":null,"metadata":{},"sourceType":"script"}