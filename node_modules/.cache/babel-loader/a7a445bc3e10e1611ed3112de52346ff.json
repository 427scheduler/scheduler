{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jenny/Desktop/SOAS/scheduler/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar call_1 = require(\"./call\");\n\nvar channel_1 = require(\"./channel\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar client_interceptors_1 = require(\"./client-interceptors\");\n\nvar CHANNEL_SYMBOL = Symbol();\nvar INTERCEPTOR_SYMBOL = Symbol();\nvar INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nvar CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\n\nvar Client =\n/*#__PURE__*/\nfunction () {\n  function Client(address, credentials) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Client);\n\n    var _a, _b;\n\n    options = Object.assign({}, options);\n    this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n    delete options.interceptors;\n    this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n    delete options.interceptor_providers;\n\n    if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n      throw new Error('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n    }\n\n    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n    delete options.callInvocationTransformer;\n\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      var channelFactoryOverride = options.channelFactoryOverride;\n      delete options.channelFactoryOverride;\n      this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n    } else {\n      this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n    }\n  }\n\n  _createClass(Client, [{\n    key: \"close\",\n    value: function close() {\n      this[CHANNEL_SYMBOL].close();\n    }\n  }, {\n    key: \"getChannel\",\n    value: function getChannel() {\n      return this[CHANNEL_SYMBOL];\n    }\n  }, {\n    key: \"waitForReady\",\n    value: function waitForReady(deadline, callback) {\n      var _this = this;\n\n      var checkState = function checkState(err) {\n        if (err) {\n          callback(new Error('Failed to connect before the deadline'));\n          return;\n        }\n\n        var newState;\n\n        try {\n          newState = _this[CHANNEL_SYMBOL].getConnectivityState(true);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n          return;\n        }\n\n        if (newState === channel_1.ConnectivityState.READY) {\n          callback();\n        } else {\n          try {\n            _this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n          } catch (e) {\n            callback(new Error('The channel has been closed'));\n          }\n        }\n      };\n\n      setImmediate(checkState);\n    }\n  }, {\n    key: \"checkOptionalUnaryResponseArguments\",\n    value: function checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n      if (arg1 instanceof Function) {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: {},\n          callback: arg1\n        };\n      } else if (arg2 instanceof Function) {\n        if (arg1 instanceof metadata_1.Metadata) {\n          return {\n            metadata: arg1,\n            options: {},\n            callback: arg2\n          };\n        } else {\n          return {\n            metadata: new metadata_1.Metadata(),\n            options: arg1,\n            callback: arg2\n          };\n        }\n      } else {\n        if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && arg3 instanceof Function)) {\n          throw new Error('Incorrect arguments passed');\n        }\n\n        return {\n          metadata: arg1,\n          options: arg2,\n          callback: arg3\n        };\n      }\n    }\n  }, {\n    key: \"makeUnaryRequest\",\n    value: function makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n      var _a, _b;\n\n      var checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n      var methodDefinition = {\n        path: method,\n        requestStream: false,\n        responseStream: false,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize\n      };\n      var callProperties = {\n        argument: argument,\n        metadata: checkedArguments.metadata,\n        call: new call_1.ClientUnaryCallImpl(),\n        channel: this[CHANNEL_SYMBOL],\n        methodDefinition: methodDefinition,\n        callOptions: checkedArguments.options,\n        callback: checkedArguments.callback\n      };\n\n      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n      }\n\n      var emitter = callProperties.call;\n      var interceptorArgs = {\n        clientInterceptors: this[INTERCEPTOR_SYMBOL],\n        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n      };\n      var call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n      /* This needs to happen before the emitter is used. Unfortunately we can't\n       * enforce this with the type system. We need to construct this emitter\n       * before calling the CallInvocationTransformer, and we need to create the\n       * call after that. */\n\n      emitter.call = call;\n\n      if (callProperties.callOptions.credentials) {\n        call.setCredentials(callProperties.callOptions.credentials);\n      }\n\n      var responseMessage = null;\n      var receivedStatus = false;\n      call.start(callProperties.metadata, {\n        onReceiveMetadata: function onReceiveMetadata(metadata) {\n          emitter.emit('metadata', metadata);\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onReceiveMessage: function onReceiveMessage(message) {\n          if (responseMessage !== null) {\n            call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n          }\n\n          responseMessage = message;\n        },\n        onReceiveStatus: function onReceiveStatus(status) {\n          if (receivedStatus) {\n            return;\n          }\n\n          receivedStatus = true;\n\n          if (status.code === constants_1.Status.OK) {\n            callProperties.callback(null, responseMessage);\n          } else {\n            callProperties.callback(call_1.callErrorFromStatus(status));\n          }\n\n          emitter.emit('status', status);\n        }\n      });\n      call.sendMessage(argument);\n      call.halfClose();\n      return emitter;\n    }\n  }, {\n    key: \"makeClientStreamRequest\",\n    value: function makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n      var _a, _b;\n\n      var checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n      var methodDefinition = {\n        path: method,\n        requestStream: true,\n        responseStream: false,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize\n      };\n      var callProperties = {\n        metadata: checkedArguments.metadata,\n        call: new call_1.ClientWritableStreamImpl(serialize),\n        channel: this[CHANNEL_SYMBOL],\n        methodDefinition: methodDefinition,\n        callOptions: checkedArguments.options,\n        callback: checkedArguments.callback\n      };\n\n      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n      }\n\n      var emitter = callProperties.call;\n      var interceptorArgs = {\n        clientInterceptors: this[INTERCEPTOR_SYMBOL],\n        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n      };\n      var call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n      /* This needs to happen before the emitter is used. Unfortunately we can't\n       * enforce this with the type system. We need to construct this emitter\n       * before calling the CallInvocationTransformer, and we need to create the\n       * call after that. */\n\n      emitter.call = call;\n\n      if (callProperties.callOptions.credentials) {\n        call.setCredentials(callProperties.callOptions.credentials);\n      }\n\n      var responseMessage = null;\n      var receivedStatus = false;\n      call.start(callProperties.metadata, {\n        onReceiveMetadata: function onReceiveMetadata(metadata) {\n          emitter.emit('metadata', metadata);\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onReceiveMessage: function onReceiveMessage(message) {\n          if (responseMessage !== null) {\n            call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n          }\n\n          responseMessage = message;\n        },\n        onReceiveStatus: function onReceiveStatus(status) {\n          if (receivedStatus) {\n            return;\n          }\n\n          receivedStatus = true;\n\n          if (status.code === constants_1.Status.OK) {\n            callProperties.callback(null, responseMessage);\n          } else {\n            callProperties.callback(call_1.callErrorFromStatus(status));\n          }\n\n          emitter.emit('status', status);\n        }\n      });\n      return emitter;\n    }\n  }, {\n    key: \"checkMetadataAndOptions\",\n    value: function checkMetadataAndOptions(arg1, arg2) {\n      var metadata;\n      var options;\n\n      if (arg1 instanceof metadata_1.Metadata) {\n        metadata = arg1;\n\n        if (arg2) {\n          options = arg2;\n        } else {\n          options = {};\n        }\n      } else {\n        if (arg1) {\n          options = arg1;\n        } else {\n          options = {};\n        }\n\n        metadata = new metadata_1.Metadata();\n      }\n\n      return {\n        metadata: metadata,\n        options: options\n      };\n    }\n  }, {\n    key: \"makeServerStreamRequest\",\n    value: function makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n      var _a, _b;\n\n      var checkedArguments = this.checkMetadataAndOptions(metadata, options);\n      var methodDefinition = {\n        path: method,\n        requestStream: false,\n        responseStream: true,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize\n      };\n      var callProperties = {\n        argument: argument,\n        metadata: checkedArguments.metadata,\n        call: new call_1.ClientReadableStreamImpl(deserialize),\n        channel: this[CHANNEL_SYMBOL],\n        methodDefinition: methodDefinition,\n        callOptions: checkedArguments.options\n      };\n\n      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n      }\n\n      var stream = callProperties.call;\n      var interceptorArgs = {\n        clientInterceptors: this[INTERCEPTOR_SYMBOL],\n        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n      };\n      var call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n      /* This needs to happen before the emitter is used. Unfortunately we can't\n       * enforce this with the type system. We need to construct this emitter\n       * before calling the CallInvocationTransformer, and we need to create the\n       * call after that. */\n\n      stream.call = call;\n\n      if (callProperties.callOptions.credentials) {\n        call.setCredentials(callProperties.callOptions.credentials);\n      }\n\n      var receivedStatus = false;\n      call.start(callProperties.metadata, {\n        onReceiveMetadata: function onReceiveMetadata(metadata) {\n          stream.emit('metadata', metadata);\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onReceiveMessage: function onReceiveMessage(message) {\n          if (stream.push(message)) {\n            call.startRead();\n          }\n        },\n        onReceiveStatus: function onReceiveStatus(status) {\n          if (receivedStatus) {\n            return;\n          }\n\n          receivedStatus = true;\n          stream.push(null);\n\n          if (status.code !== constants_1.Status.OK) {\n            stream.emit('error', call_1.callErrorFromStatus(status));\n          }\n\n          stream.emit('status', status);\n        }\n      });\n      call.sendMessage(argument);\n      call.halfClose();\n      return stream;\n    }\n  }, {\n    key: \"makeBidiStreamRequest\",\n    value: function makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n      var _a, _b;\n\n      var checkedArguments = this.checkMetadataAndOptions(metadata, options);\n      var methodDefinition = {\n        path: method,\n        requestStream: true,\n        responseStream: true,\n        requestSerialize: serialize,\n        responseDeserialize: deserialize\n      };\n      var callProperties = {\n        metadata: checkedArguments.metadata,\n        call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n        channel: this[CHANNEL_SYMBOL],\n        methodDefinition: methodDefinition,\n        callOptions: checkedArguments.options\n      };\n\n      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n      }\n\n      var stream = callProperties.call;\n      var interceptorArgs = {\n        clientInterceptors: this[INTERCEPTOR_SYMBOL],\n        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n      };\n      var call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n      /* This needs to happen before the emitter is used. Unfortunately we can't\n       * enforce this with the type system. We need to construct this emitter\n       * before calling the CallInvocationTransformer, and we need to create the\n       * call after that. */\n\n      stream.call = call;\n\n      if (callProperties.callOptions.credentials) {\n        call.setCredentials(callProperties.callOptions.credentials);\n      }\n\n      var receivedStatus = false;\n      call.start(callProperties.metadata, {\n        onReceiveMetadata: function onReceiveMetadata(metadata) {\n          stream.emit('metadata', metadata);\n        },\n        onReceiveMessage: function onReceiveMessage(message) {\n          if (stream.push(message)) {\n            call.startRead();\n          }\n        },\n        onReceiveStatus: function onReceiveStatus(status) {\n          if (receivedStatus) {\n            return;\n          }\n\n          receivedStatus = true;\n          stream.push(null);\n\n          if (status.code !== constants_1.Status.OK) {\n            stream.emit('error', call_1.callErrorFromStatus(status));\n          }\n\n          stream.emit('status', status);\n        }\n      });\n      return stream;\n    }\n  }]);\n\n  return Client;\n}();\n\nexports.Client = Client;","map":null,"metadata":{},"sourceType":"script"}